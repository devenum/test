# Лабораторная работа №9 (BMP)

## Содержание

1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Формат входных и выходных изображений](#формат-входных-и-выходных-изображений)
    1. [Советы](#советы)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Базовые требования](#базовые-требования)
    1. [Дополнительные требования](#дополнительные-требования)
    1. [Консольное приложение](#консольное-приложение)
    1. [Обработка ошибок](#обработка-ошибок)
    1. [Структура программы](#структура-программы)
    1. [Частичные решения](#частичные-решения)
1. [Инструкция по сдаче](#инструкция-по-сдаче)
1. [Система оценки](#система-оценки)
1. [Сроки сдачи](#сроки-сдачи)

## Задание
Реализуйте приложение `./bmp`, которое вырезает прямоугольник из входного BMP-файла с изображением,
поворачивает этот прямоугольник на 90 градусов по часовой стрелке и сохраняет результат в отдельный выходной файл.

### Формат входных и выходных изображений
Все изображения хранятся в заданном формате:

* Общий формат — [BMP](https://ru.wikipedia.org/wiki/BMP).
* В рамках формата BMP используется формат *DIB* с заголовком `BITMAPINFOHEADER` (версия 3).
* Значение поля `biHeight` (высота изображения) строго больше нуля.
* Значение поля `biSizeImage` (количество байт, хранящих изображение) строго больше нуля.
* Используются 24 бита цвета на пиксель (один байт на цветовой канал в [модели RGB](https://ru.wikipedia.org/wiki/RGB)).
* Палитра (таблица цветов) не используется.
* Сжатие не используется.

Таким образом, вам требуется обработать лишь один конкретный вид BMP,
не требуется поддерживать все возможности формата.

В качестве примера входного файла вам даны [`lena-512.bmp`](./solution/test-data/t1-02-lena-512.bmp) и [`t1-01-small-one.bmp`](./solution/test-data/t1-01-small-one.bmp).
Также некоторые графические редакторы могут генерировать изображение в нужном формате
(«24-битное изображение BMP»), проверяйте поля в заголовках.

#### Требования к выходному изображению
1. Выходное изображение должно содержать ту же информацию в заголовках, что и входное, кроме тех, что необходимо изменить (например, размеры).
2. Все байты, используемые для выравнивания данных вне заголовков — нули.

### Советы
* Чтобы посмотреть байты, можете использовать команду `hexdump -C t1-01-small-one.bmp` (не путать с `hexdump t1-01-small-one.bmp`).
* Сначала научитесь читать `t1-01-small-one.bmp` при помощи hex-редактора, а уже потом пытайтесь его прочитать в коде.
* Сначала выпишите алгоритм для поворота изображения на 90 градусов на бумаге, а уже потом реализуйте его.
* Убедитесь, что вы корректно работаете с неквадратными изображениями.
* Убедитесь, что вы корректно работаете с изображениями со стороной, не делящейся на 4 (и при чтении, и при записи).
* Убедитесь, что вы открываете файл в режиме для бинарного ввода-вывода (`std::ios::binary`), это
  влияет на баллы за корректность.
  Вывод `\n` отличается под Windows и Linux, и, строго говоря, вывод некоторых символов в текстовом режиме — UB.
* Отнаследуйте исключения от `std::runtime_error`, чтобы появился конструктор
  от `std::string` и вы смогли сделать произвольные сообщения об ошибках.
* Placement new только существенно усложнит решение.
* Если используете `std::exit`, перечитайте документацию и поймите, как там может утечь память.
  ОС её, конечно, освободит, но у автопроверок это всё ещё считается утечкой.

## Требования к корректности решения
### Базовые требования
Действуют [стандартные требования](../common/).

Однако флаги для статических проверок несколько изменены:

* У `clang-tidy` отключены следующие проверки:
  * `cppcoreguidelines-pro-bounds-pointer-arithmetic` (какая-то арифметика указателей может быть полезна при работе с изображениями).
  * `cppcoreguidelines-pro-type-reinterpret-cast` (нужен в нескольких местах).

Максимальное суммарное количество строк (включая пустые) в файлах `.hpp` и `.cpp` — 600.
Файл `image_test.cpp` не считается, можете дописывать туда всё что угоно.
Полное авторское решение занимает 374

### Дополнительные требования
* Можно считать, что приложение всегда компилируется и запускается на [little-endian](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA_%D0%B1%D0%B0%D0%B9%D1%82%D0%BE%D0%B2) системах.
  * Также можно пользоваться `#pragma pack`.
* Ваше приложение не должно использовать памяти больше, чем `In+Out+O(w+h)`,
  где `In` — размер входного файла в байтах, `Out` — размер выходного файла, `w` и `h` — размеры исходного изображения, `O` — обычное асимптотическое О-большое.
  * Считаем, что `vector<>` выделяет памяти ровно столько, сколько попросили.
    * Стандартные библиотеки libstdc++ (GNU) и libc++ (clang) так и делают, а не форсируют степень двойки в качестве `capacity`.
    * Если начать делать `push_back`/`insert`, то уже может произойти резервирование памяти в два раза.
  * Например, если входное изображение имеет ширину `N` пикселей и высоту `M` пикселей, выходное имеет размер 1 пиксель и дополнительного выравнивания не требуется,
    то завести два `vector<char>` размером `3*N*M` байт нельзя, а вот один — можно.
    Также можно завести любое _константное_ количество векторов размера `N` или `M`.
  * По стилю: работать с данными из памяти обычно проще, чем из файла
    (про memory-mapped files мы ещё не знаем, к тому же под Linux/Windows соответствующие функции называются по-разному),
    поэтому наверняка проще считать файл в память целиком, чем пытаться читать лишь по необходимости.
* Чтение или запись одного BMP-файла требует не более 2 операций ввода-вывода независимо от размеров.
* На создание изображения (экземпляр `image`) требуется константное количество выделений памяти.
  Например, нельзя использовать для хранения `vector<vector<T>>`.
* Помните, что обращаться к массиву `char`'ов, как к объектам типа `T`, если не вызван placement new — UB.
  * А если вызываете placement new, то обязательно надо вызывать соответствующий деструктор.
  * Если конструктор/деструктор у `T` пустой, компилятор это наверняка соптимизирует.
  * Это требуется сделать, несмотря на то, что на практике вряд ли выстрелит:
    так все всегда делали, да и в C++20 появился [P0593R6](http://wg21.link/p0593r6).
* Копировать байты в существующие объекты удобно при помощи [`std::memcpy`](https://en.cppreference.com/w/cpp/string/byte/memcpy).
* Ввод-вывод фиксированных структур формата BMP идёт напрямую при помощи `istream::read`/`ostream::write`
  и похожих механизмов, а не побайтовым считыванием в цикле.
* Все сущности должны по максимуму определяться в своих `.cpp`, а не заголовках.

### Консольное приложение
Приложение запускается следующей командой:

```
./bmp crop-rotate ‹in-file› ‹out-file› ‹x› ‹y› ‹w› ‹h›
```

Используемые параметры:

* `crop-rotate` — обязательный параметр, означающий выполняемое действие.
* `in-file` — имя входного файла с изображением.
* `out-file` — имя выходного файла с изображением.
* `x`, `y` — координаты левого верхнего угла области, которую необходимо вырезать и повернуть. Координаты начинаются с нуля, таким образом *(0, 0)* — это верхний левый угол.
* `w`, `h` — ширина и высота области до поворота.

Таким образом, если обозначить ширину и высоту исходного изображения за `W` и `H` соответственно, верны следующие неравенства:

* `0 <= x < x + w <= W`
* `0 <= y < y + h <= H`

Стандартный поток вывода остаётся пустым.

### Обработка ошибок
При возникновении следующих ошибок приложение обязано завершиться с кодом возврата 1 и выдать в стандартный
поток ошибок соответствующее сообщение (формат важен).

| Категория | Ошибка | Пример сообщения | Комментарий |
| --- | --- | --- | --- |
| Недостаточно аргументов | | `Missing arguments` | Проверяйте `argc` |
| Не удалось открыть файл `a.bmp` на диске (на чтение или запись) | | `Unable to open file "a.bmp"` |
| Неверный формат BMP | Не та версия | `Invalid BMP: expected version 3 and header size 40, but header size is 108` | |
| Неверный формат BMP | Неположительная высота | `Invalid BMP: expected positive biHeight, got -123` | |
| Неверный формат BMP | Не то количество бит на пиксель | `Invalid BMP: expected 24 bits per pixel, got 8` | |
| Неверный формат BMP | Используется палитра | `Invalid BMP: color palette is unsupported` | |
| Неверные аргументы | Область для вырезания не лежит внутри изображения | `The requested area is not a subimage` | Переполнений `int` не будет, с запасом |
| Недостаточно памяти | | `Insufficient memory` | В C++ ловите `std::bad_alloc` |

Гарантируется, что:

* За запуск программы произойдёт не более одной ошибки.
* Файл BMP всегда корректен (возможно, выходит за рамки формата, требуемого в этой задаче).
* Не будет ошибок кроме перечисленных выше.
  * Например, если аргументов достаточно, то `x`/`y`/`w`/`h` являются корректными целыми числами, помещающимися в `int` с запасом.
* Входной файл имеет размер хотя бы 54 байта.
  В частности, значение поле `bfSize` не меньше 54.
* Пиксельные данные начинаются сразу после заголовков,
  то есть значение поля `bfOffBits` совпадает с суммарным размером заголовков.

### Структура программы
* Должен быть создан отдельный класс `image` для работы с изображениями
  и минимум двумя отдельными методами: `crop` (вырезание фрагмента) и `rotate_clockwise` (поворот на 90 градусов).
  * Если будете копировать, осторожно с потребляемой памятью.
  * Связывать этот класс с форматом BMP-файлов допустимо, но необязательно.
    Осторожно с памятью.
* Разбор аргументов, ловля исключений и обработка ошибок (вывод на экран) должны производиться только в `main.cpp`.
  * В частности, класс для работы с изображениями и функции ввода/вывода не имеют права выводить что-то на экран или завершать программу.
  * Кидать исключения, разумеется, можно где угодно.
* Для обработки ошибок используйте исключения.
  * По типу пойманного исключения должно быть можно определить категорию ошибки.
  * Если поймано исключение вашего типа, то его `what()` должно совпадать с сообщением об ошибке, которое выводится на экран.

### Частичные решения
Вы можете реализовать любой префикс из четырёх подзаданий ниже и получить частичные баллы:

1. Есть следующие упрощения:
    1. Требуется работа только на публичных тестах с `t1-01-small-one.bmp` и всех тестах, где размер в пикселях каждой стороны входного и выходного файла делится на 4.
    2. Ограничений на объём используемой памяти нет.
    3. Обработка ошибок не требуется.
    4. Для чтения или записи одного BMP-файла разрешается сделать `2 + 2 * H` операций ввода-вывода, где `H` — высота изображения.
       Всё ещё запрещено читать все поля/пиксели по отдельности.
    5. Для создания изображения разрешается использовать `O(H)` выделений памяти.
2. Убираются упрощения 1, 2: должно работать на тестах любого размера с ограниченной памятью, но не надо обрабатывать ошибки и разрешается неэффективно читать файлы и выделять память.
3. Убирается ещё и упрощение 3: требуется обработать все ошибки, но разрешается неэффективно читать файлы и выделять память.
4. Убираются все упрощения: требуется эффективно читать файлы и выделять память с BMP.

## Инструкция по сдаче
[Схема стандартная](../common/#формат-сдачи): вы должны выполнить
задание в отдельной ветке своего существующего закрытого репозитория в организации и в нём же создать Pull Request.
Никаких форков!
В этом задании должно хватить веб-интерфейса GitHub, если возникают проблемы — попросите практика помочь.

Если вы хотите сдать только некоторые части задания, удалите остальные тесты из `tests.txt`.

Обратите внимание, что публичных тестов на часть 4 нет.
Если вы сдаёте часть 3 — это автоматически попытка сдать и часть 4.

## Система оценки
[Схема стандартная](../common/#система-оценки), баллы:

|Выполненные части|Макс. корректность|Макс. стиль|Макс. итог|
|---|---|---|---|
|1  |1.5|1.5|  3|
|1-2|3  |2  |  5|
|1-3|5  |3  |  8|
|1-4|6  |4  | 10|

## Сроки сдачи
Задание выдано 13 апреля 2025 (воскресенье).
Ниже в каждом случае указано московское время.

* **Дедлайн сдачи:** 20 апреля (воскресенье), **22**:59.
* Ожидаемый срок проверки: 27 апреля (воскресенье).
* Если первая попытка сдачи достаточно разумна (на усмотрение принимающего),
  то вы можете сделать ещё попытку исправлений или даже несколько.
    * Предложение актуально даже если вы получили автоматический ноль за первую попытку.
    * Выставляется максимум из всех попыток.
* **Срок исправлений**: 4 мая (воскресенье), **22**:59.
