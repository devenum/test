# Лабораторная работа №7 (interpreter)

## Содержание

1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Советы](#советы)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Базовые требования](#базовые-требования)
    1. [Дополнительные требования](#дополнительные-требования)
    1. [Формат команд](#формат-команд)
    1. [Обработка ошибок](#обработка-ошибок)
    1. [Частичные решения](#частичные-решения)
1. [Инструкция по сдаче](#инструкция-по-сдаче)
1. [Система оценки](#система-оценки)
1. [Сроки сдачи](#сроки-сдачи)

## Задание
Требуется реализовать интерпретатор assembler-like языка программирования.
В этом языке доступно ровно десять регистров с именами от `$0` до `$9`,
каждый регистр хранит матрицу произвольного размера из целочисленных элементов.
Команды: загрузка матрицы из файла в регистр, вывод регистра на экран,
сложение, умножение регистров и вывод элемента матрицы.
Каждый регистр по умолчанию хранит матрицу размером `0x0`.

Команды поступают со стандартного потока ввода, весь вывод (включая ошибки)
идёт на стандартный поток вывода.

Гарантируется, что все элементы всех матриц, возникающие в процессе работы,
помещаются в тип `int`, а также что все используемые компиляторы
при конвертации между знаковыми и беззнаковыми типами сохраняют остаток по модулю `2^N`.

Для обработки ошибок должен использоваться механизм исключений.

### Советы
* Если требуется, можно и нужно гуглить и подробно обсуждать между собой матрицы как математические объекты и как у них устроены операции.
* Вынесите интерпретатор в отдельные функции или класс, так может оказаться удобнее.
  Вы можете даже завести отдельные единицы трансляции, добавив их в CMake.
* Брошенное исключение должно содержать всю необходимую информацию для вывода сообщения на экран.
* Конструкция `catch (...) { throw; }` строго бесполезна, не пишите так.
  * Nit: на самом деле её иногда можно писать на самом верхнем уровне `main`, чтобы гарантировать вызовы локальных деструкторов.
* Постарайтесь поменьше ловить исключения.
  Особенно если вы их ловите, а потом сразу перебрасываете — это сильно загромождает код.
  Сразу кидайте правильное исключение.
* Если вы сначала проверяете существование файла, а потом уверенно его открываете,
  в вашем коде есть уязвимость [TOCTOU (time-to-check to time-to-use)](https://www.opennet.ru/opennews/art.shtml?num=56551).

## Требования к корректности решения
### Базовые требования
Действуют [стандартные требования](../common/), но:

* Тестирования с `-stdlib=libc++` нет из-за [бага в Ubuntu](https://bugs.launchpad.net/ubuntu/+source/llvm-toolchain-14/+bug/2000322).
* Сборка происходит не напрямую, а через CMake.
  Вы можете редактировать `CMakeLists.txt` и изменять набор единиц трансляции и файлов как угодно.
* Максимальное суммарное количество строк (включая пустые) в файлах `.hpp` и `.cpp` — 500.
  Полное авторское решение занимает 304.

### Дополнительные требования
* Весь код по максимуму находится внутри `namespace matrix_interpreter`.
* Вся работа с одной матрицей (кроме, возможно, ввода-вывода) вынесена в отдельный класс `matrix` с value-семантикой (как обычно в C++).
  Интерпретатор в `main.cpp` использует этот класс.
* Файлы `matrix.*` содержат только то, что нужно для работы с классом `matrix` в отрыве от интерпретатора.
  Скорее всего, только сам класс и исключения, которые он выбрасывает.
* Требуется пометить при помощи `noexcept` те и только те функции, которые в принципе не могут кидать исключения.
* Нельзя выводить сообщение об ошибке без выбрасывания исключения.
  Когда ниже говорится "выводится ошибка", подразумеватся, что после обработки исключения соответствующее сообщение появляется на экране.
  * В частности, в файлах `matrix.*` никакого `std::cout` быть не должно.

### Формат команд
Каждая строчка входа (по конвенциям POSIX, включя неполную строку в конце ввода) интерпретируется отдельно.
Строчка разбивается по пробельным символам на токены — максимальные по включению непустые последовательности непробельных символов.
В частности, пробельные символы в начале или в конце строки полностью игнорируются.
Выполнение завершается либо при наступлении конца стандартного ввода, либо по команде `exit`.

Первый токен является названием команды.
Все корректные команды перечислены ниже.
Если используется неизвестная команда, требуется вывести ошибку `Unknown command: '<cmd>'`,
где `<cmd>` — название команды.
При прочих нарушениях формата команды выводится ошибка `Invalid command format`.

Если параметр команды — регистр, то соответствующий токен должен состоять ровно из
двух символов: `$` и цифра от 0 до 9 — номер регистра.
Если ожидается регистр, а нашлось что-то ещё, то выводится ошибка `'<foo>' is not a register`,
где `<foo>` — соответствующий токен.

#### `load`
Принимает ровно два параметра: регистр и имя файла.
Загружает матрицу из файла в регистр.
Старое значение регистра игнорируется.

Формат хранения матрицы в файле:
```
<#rows, неотрицательное целое не больше 10^6> <#cols, неотрицательное целое не больше 10^6>
<element 0-0> ... <element 0-(#cols-1)>
...
<element (#rows-1)-0> ... <element (#rows-1)-(#cols-1)>
```
Элементы матрицы — целые числа, не превосходящие 100 по модулю, записаны в десятичной системе.

Матрицы из нуля строк или нуля столбцов преобразуются в матрицы размером `0x0`.

Если файл не удалось открыть для чтения, требуется вывести ошибку `Unable to open file '<fname>'`,
где `<fname>` — имя файла.
Любая непустая строка считается потенциально корректным именем файла.
Хотя в зависимости от ОС и файловой системы бывают ограничения ([пример](https://stackoverflow.com/questions/1976007/what-characters-are-forbidden-in-windows-and-linux-directory-names)),
в этом задании их требуется _не_ проверять самостоятельно.

Гарантируется, что если файл существует, то либо формат файла полностью корректен, либо
в конце файла не хватает каких-либо чисел.
В этом случае выводится ошибка: `Invalid file format`.
Другие случаи в этом задании обрабатывать не требуется.
В частности, файл может быть пуст или содержать ровно одно число, но не может содержать
символы, кроме пробельных, минуса, плюса и цифр.

### `print`
Принимает один параметр: регистр.
Построчно печатает элементы матрицы, хранящейся в `<reg>`.

### `elem`
Принимает три параметра: регистр, номер строки и столбца (нумерация с нуля).
Печатает на экран соответствующий элемент матрицы.
Если элемента не существует, на экран выводится ошибка: `Requested element is out of bounds`.
У корректной команды `elem` номер строки и столбца — целое неотрицательное число
в десятичной системе счисления между 0 и 10^6 включительно; допускаются ведущие нули и не допускаются
символы, кроме цифр.

### `exit`
Принимает ноль параметров.
Успешно завершает работу интерпретатора.

### `add`
Принимает два параметра: регистры `A` и `B`.
Записывает в `A` результат `A + B` (обычное сложение матриц, поэлементное).
Если размеры матриц не совпадают, на экран выводится ошибка: `Dimension mismatch: lhs=<A>, rhs=<B>`,
где `<A>` — не совпадающее измерение матрицы `A` (число), а `<B>` — соответствующее ему измерение матрицы `B` (число, не равное `<A>`).
Сначала проверяется количество строк, потом столбцов.

### `mul`
Принимает два параметра: регистры `A` и `B`.
Записывает в `A` результат `A * B` (обычное умножение матриц).
Если размеры матриц не позволяют выполнить умножение, на экран выводится ошибка: `Dimension mismatch: lhs=<A>, rhs=<B>`,
где `<A>` — не совпадающее измерение матрицы `A` (число), а `<B>` — соответствующее ему измерение матрицы `B` (число, не равное `<A>`).

Достаточно умножать наивным алгоритмом "за куб", что-то быстрее не требуется.

### Обработка ошибок
* Для обработки всех ошибок используйте исключения.
  * Если бросается исключение (неважно, стандартное или своё), по его типу должно быть
    можно однозначно определить тип ошибки (то есть сообщение за исключением параметров вроде имени файла или пары чисел).
    В частности, нельзя просто везде кидать `std::runtime_error` — есть несколько разных видов сообщений.
  * Свои типы исключений наследуйте от `std::exception` или его наследников.
    У своих типов исключений `what()` должно в точности совпадать с сообщением об ошибке, которое выводится на экран.
  * Запрещается перезаворачивать стандартные исключения в свои, если только это не требуется из-за предыдущих условий.
  * Используйте поменьше проверок при помощи `if` и побольше операций, которые бросают исключение в понятных случаях.
* Проверка операций с матрицами на корректность должна производиться исключительно внутри класса `matrix`,
  а не в `main.cpp` рядом с чтением команды.
  Если операция некорректна, выбрасывается исключение.
* Аналогично, вывод ошибок на экран должен быть максимально сконцентрирован в одном месте и визуально отделён от основной логики интерпретатора.
* При нехватке памяти при выполнении любой команды (возникшее исключение `std::bad_alloc`)
  на экран выводится ошибка: `Unable to allocate memory`.
  Если памяти всё ещё не хватает для нормального продолжения работы программы, поведение не определено.
  Если память кончилась при выполнении `std::getline`, поведение не определено ([не очень ясно, что происходит по стандарту](https://stackoverflow.com/questions/64564963/what-happens-when-getline-reads-a-line-that-is-larger-than-system-memory)).
* Если при выполнении команды возникла ошибка, описанная в задании, требуется:
  * Вывести в стандартный поток вывода (не ошибок) соответствующее сообщение.
  * Оставить значения регистров такими же, как и до начала выполнения команды.
    Так мы обеспечиваем _строгую гарантию исключений_ с точки зрения пользователя.
  * Ожидать следующую команду.
* Обрабатывается только первая возникшая ошибка, порядок следующий сверху вниз:
  * Неизвестная команда.
  * Некорректный формат команды или неверный синтаксис регистра (гарантируется, что не произойдёт две одновременно).
  * Ошибки, специфичные для каждой отдельной команды. В каждой команде порядок обработки ошибок должен однозначно следовать из условия задания.
* Поведение программы при остальных ошибках не определено.
  * В частности, если ошибка произошла при выводе сообщения на экран, при считывании очередной строчки со стандартного ввода или инициализации программы.
  * Также поведение не определено, если в результате вычислений получился элемент матрицы, не влезающий в тип `int`.

### Частичные решения
Вы можете реализовать любой префикс из четырёх подзаданий ниже и получить частичные баллы:

1. Только команды `load`, `print`, `elem`, `exit`, причём обработка никаких ошибок не требуется.
2. То же самое, только с поддержкой всех видов ошибок, возникающих при выполнении корректной команды.
   Каждая строка содержит ровно одну корректную команду.
3. Добавляются команды `add`, `mul` со своими ошибками.
4. Корректно обрабатываются ошибки в синтаксисе команд.

## Инструкция по сдаче
[Схема стандартная](../common/#формат-сдачи): вы должны выполнить
задание в отдельной ветке своего существующего закрытого репозитория в организации и в нём же создать Pull Request.
Никаких форков!
В этом задании должно хватить веб-интерфейса GitHub, если возникают проблемы — попросите практика помочь.

Если вы хотите сдать только некоторые части задания, удалите остальные тесты из `tests.txt`.

## Система оценки
[Схема стандартная](../common/#система-оценки), баллы:

|Выполненные части|Макс. корректность|Макс. стиль|Макс. итог|
|---|---|---|---|
|1  |1  |1  | 2|
|1-2|3  |2  | 5|
|1-3|4  |3  | 7|
|1-4|6  |4  |10|

## Сроки сдачи
Задание выдано 3 февраля 2025 (понедельник).
Ниже в каждом случае указано московское время.

* **Дедлайн сдачи:** 10 февраля (понедельник), **22**:59.
* Ожидаемый срок проверки: 17 февраля (понедельник).
* Если первая попытка сдачи достаточно разумна (на усмотрение принимающего),
  то вы можете сделать ещё попытку исправлений или даже несколько.
    * Предложение актуально даже если вы получили автоматический ноль за первую попытку.
    * Выставляется максимум из всех попыток.
* **Срок исправлений**: 24 февраля (понедельник), **22**:59.
