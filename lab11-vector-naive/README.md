# Лабораторная работа №11 (vector-naive)

## Содержание

1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Гарантии элементов](#гарантии-элементов)
    1. [Поддерживаемые операции](#поддерживаемые-операции)
    1. [Выделение памяти](#выделение-памяти)
    1. [Советы](#советы)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Стандартные требования](#стандартные-требования)
    1. [Дополнительные требования](#дополнительные-требования)
    1. [Закрытые тесты](#закрытые-тесты)
    1. [Частичные решения](#частичные-решения)
1. [Инструкция по сдаче](#инструкция-по-сдаче)
1. [Система оценки](#система-оценки)
1. [Сроки сдачи](#сроки-сдачи)

## Задание
Реализуйте динамический массив `vector<T, Alloc = std::allocator<T>>`:

* Работает аналогично `std::vector<T, Alloc>`, если не сказано иное.
  * Некоторые требования строже, чем в стандарте C++ к вектору.
    Например, у нашего вектора есть чёткое moved-from state
    и алгоритм определения `capacity`.
  * Аллокатор `Alloc` используется для выделения памяти вместо `new T[]`/`delete[]` для упрощения тестирования, [смотри ниже](#выделение-памяти).
* Владеет всеми находящимися внутри элементами.
* Все элементы хранятся в памяти подряд.
* Память выделяется заранее независимо от создания элементов.
  * Отдельно есть количество элементов (`size()`), а отдельно — сколько элементов можно создать без перевыделения памяти (`capacity()`).
  * В частности, это позволяет достичь амортизированно константного времени работы для `push_back()`.
* Все операции предоставляют максимально возможную гарантию исключений.
  * В частности, если операция над вектором предоставляет строгую гарантию, то при выбрасывании исключения не может измениться
    ни `capacity()`, ни адреса лежащих в векторе элементов.
  * Гарантируется, что операции над `T` __не бросают исключений__.
* Требуется делать как можно меньше выделений памяти и операций с `T` (даже если это просто перемещения),
  причём не просто асимптотически, а учитывать точное количество.
  * При этом дать максимально возможную гарантию **важнее**, чем скорость работы или потребляемая память.

### Гарантии элементов
Тип `T` является полным и удовлетворяет требованиям
[`MoveConstructible`](https://en.cppreference.com/w/cpp/named_req/MoveConstructible),
[`MoveAssignable`](https://en.cppreference.com/w/cpp/named_req/MoveAssignable),
[`Destructible`](https://en.cppreference.com/w/cpp/named_req/Destructible),
причём все три перечисленных специальных метода не бросают исключений (предоставляют nothrow exception safety).

Также тип `T` может удовлетворять какому-ту подмножеству требований:
[`DefaultConstructible`](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible),
[`CopyConstructible`](https://en.cppreference.com/w/cpp/named_req/CopyConstructible),
[`CopyAssignable`](https://en.cppreference.com/w/cpp/named_req/CopyAssignable).
В этом случае соответствующие специальные методы __не бросают исключений__.

Гарантируется, что объект тип `T` не пытается обращаться к вектору, в котором лежит.
Например, при выполнении `vector<T> v(10)` не будет попыток обратиться к `v.size()` из конструктора `T()`.
В процессе выполнения любого метода нельзя обращаться к вектору (например, нельзя в конструкторе спрашивать size).
Аналогично, при вызове `v.resize(v.size() + 1)` конструктор `T` не будет пытаться обратиться к `v.capacity()` или сделать `v.pop_back()`.
При это обращаться к каким-нибудь другим `vector` может.

### Поддерживаемые операции
Ниже считаем, что:

* В векторе `v` лежит `n` элементов, в векторе `v2` — `m` элементов.
* Все операции с индивидуальными элементами работают за `O(1)`.
* Выделение и освобождение памяти работает за `O(1)`.

Асимптотика указана в худшем случае, если не указано иное.
Если получилось `O(0)`, то считайте, что это на самом деле `O(1)`.

| Подзадача | Пример | Описание | Когда доступна | Время работы |
| --- | --- | --- | --- | --- |
| 1 | `vector v;` | Создаёт пустой `vector` | Всегда | `O(1)` |
| 1 | `vector v(n);` | Создаёт `vector` из `n` элементов | `T` — `DefaultConstructible` | `O(n)` |
| 1 | `vector v(n, t);` | Создаёт `vector` из `n` элементов-копий `t` | `T` — `CopyConstructible` | `O(n)` |
| 2 | `vector v2 = v;` | Копирует `v` в `v2` | `T` — `CopyConstructible` | `O(n)` |
| 1 | `vector v2 = std::move(v);` | Перемещает `v` в `v2`, `v` становится пустым | Всегда | `O(1)` |
| 2 | `v2 = v;` | Копирует `v` в `v2` | `T` — и `CopyConstructible`, и `CopyAssignable` | `O(n + m)` |
| 1 | `v2 = std::move(v);` | Перемещает `v` в `v2`, `v` становится пустым | Всегда | `O(m)` |
| 1 | `v.empty()` | Возвращает `true` если и только если вектор пуст | Всегда | `O(1)` |
| 1 | `v.size()` | Возвращает количество элементов | Всегда | `O(1)` |
| 1 | `v.capacity()` | Возвращает объём внутреннего буфера | Всегда | `O(1)` |
| 1 | `v[k]` | Обращение к `k`-у элементу, при выходе за границу поведение не определено | Всегда | `O(1)` |
| 2 | `v.at(k)` | Обращение к `k`-у элементу, выкидывает `std::out_of_range` при обращении за границы | Всегда | `O(1)` |
| 3 | `v.reserve(k)` | Делает `capacity()` равным или большим `k` | Всегда | `O(n)` |
| 3 | `v.push_back(t);` | Копирование элемента в конец | `T` — `CopyConstructible` | `O(1)` (амортизированно) |
| 3 | `v.push_back(T());` | Перемещение элемента в конец | Всегда | `O(1)` (амортизированно) |
| 1 | `v.pop_back();` | Удаление элемента с конца, для пустого вектора поведение не определено | Всегда | `O(1)` |
| 3 | `v.resize(k);` | Удаляет элементы с конца вектора или добавляет сконструированные по умолчанию в конец | `T` — `DefaultConstructible` | `O(\|k - n\|)` (амортизированно) |
| 3 | `v.resize(k, t);` | Удаляет элементы с конца вектора или добавляет копии `t` в конец | `T` — `CopyConstructible` | `O(\|k - n\|)` (амортизированно) |
| 2 | `v.clear();` | Удаление всех элементов | Всегда | `O(n)` |
| 1 | `}` | Деструктор | Всегда | `O(n)` |

* Используйте `std::size_t` для размеров и индексов.
* Все операции с `vector<T>` должны предоставлять хотя бы строгую гарантию исключений (strong exception safety),
  а при возможности — отсутствие исключений (nothrow exception safety) и соответствующую пометку `noexcept` в сигнатуре метода.
  * Вам требуется самостоятельно понять, какую самую строгую гарантию может обеспечить каждая операция.
* Порядок создания и удаления элементов остаётся на ваше усмотрение.
* Все операции не изменяют `capacity()` или адреса элементов, если только без этого не обойтись
  для обеспечения нужной асимптотики или гарантии безопасности исключений.
* В любой момент `capacity()` вектора должно быть либо нулём, либо степенью двойки.
* Методы, увеличивающие или инициализирующие `capacity()`, должны выбирать минимально возможное значение.
  * При этом обеспечить строгую гарантию и минимизировать количество операций важнее.

### Выделение памяти
В этом задании для выделения памяти без инициализации элементов используйте следующие операции:

```c++
using Alloc = std::allocator<int>;  // Переданный в vector<> аллокатор.
// ......
int *memory = Alloc().allocate(10);  // Выделение памяти под 10 элементов.
// ... любые операции с memory ...
Alloc().deallocate(memory, 10);  // Удаление памяти под 10 элементов по адресу memory.
```

Выделение памяти (`allocate`) может выкинуть произвольное исключение.
`deallocate` исключений не кидает.

Запрещается использовать любые другие способы выделения памяти:
вызовы `new`/`delete`/`new[]`/`delete[]`/`malloc`/`free`/`aligned_alloc`,
small object optimization, писать свои аллокаторы с глобальными или thread-local переменными...
При этом placement new вида `new (.....) my_type(.....)` для вызова конструктора
в уже выделенной памяти разрешается, без него не обойтись.

Это нужно, чтобы автотесты могли единообразно проверять работу с памятью и стандартного
вектора, и вашей реализации.
При этом в автотестах всё ещё можно использовать любые стандартные контейнеры
со стандартным аллокатором и они не будут мешать тестированию.

Мы не будем погружаться в дебри аллокаторов, выделения памяти или выравнивания.
Предполагаем, что аллокатор уже делает всё правильно.

### Советы
* Запускайте все тесты с санитайзерами и проверкой на утечки.
  * Если санитайзер не показывает в stack trace даже ваши функции (не то что номера строк), попробуйте Valgrind
    или установить переменную среды `ASAN_OPTIONS=fast_unwind_on_malloc=0` ([это не баг](https://github.com/llvm/llvm-project/issues/54977))
* Повторите практику с `minivector` (тоже с санитайзерами/Valgrind)
* Деструктор надо вызывать у любого живого объекта, в том числе в moved-from state.
  Даже если этот деструктор ничего не делает для конкретного `T`.
* Решайте подзадачи и проходите тесты последовательно, начиная с первой.
  * При этом иногда придётся переписывать код, это нормально.
* В этом задании ровно одно место, где может вылететь исключение: аллокатор.
  Из-за этого почти везде из базовой гарантии исключений будет автоматически следовать строгая.
* Перед освобождением куска памяти обязательно вызвать деструкторы у всех созданных в этой памяти объектов.
* Будьте осторожны с порядком операций в коде: вам нужна строгая гарантия исключений.
* Напишите себе вспомогательных функций на частые операции вроде `std::uninitialized_copy`/`std::destroy`.
  При этом их реализации из стандартной библиотеки нельзя использовать в решении или копировать.
  * Вы можете даже делать шаблонные приватные функции, которые принимают параметр-функтор вроде «как инициализировать элемент».
    Это может уменьшить количество копипасты.
* Некоторые конструкторы должны быть `explicit`, некоторые операции — const-qualified или ref-qualified, некоторые — `noexcept`.
  Иногда в комбинации, иногда есть несколько перегрузок.
  * Даже если в стандартном векторе этих квалификаторов нет (или наоборот) ради обратной совместимости:
    например, добавление любого ref qualifier в C++11 могло сломать старый код, поэтому так не сделали.
  * Используйте rvalue ref qualifier (`&&`), чтобы отличить lvalue/rvalue неконстантный `*this` — он работает в точности как обычный ref-qualifier.
* Если `push_back(T v)` принимает свой аргумент по значению, то добавление элемента в конец будет требовать либо два перемещения, либо перемещение и копирование:
  сначала создание аргумента, а потом создание элемента вектора.
  В некоторых подзадачах требуется делать меньше операций с `T`.
* Делать `catch` и потом сразу бросать то же самое исключение — бесполезное занятие.
  * В официальном решении вообще отсутствует слово `catch`.
* Вы можете скомпилировать тесты с флагом `-DTEST_STD_VECTOR` (это делает цель `vector-test-std`), чтобы запустить часть тестов
  на `std::vector` вашего компилятора.
* Вы можете запустить скомпилированные тесты с флагом `-r=verbose`, чтобы перед каждым `TEST_CASE`/`SUBCASE` на экран
  выводилось его название.

## Требования к корректности решения
### Стандартные требования
Действуют [стандартные требования](../common/).

Однако флаги для статических проверок несколько изменены:

* У `clang-tidy` отключены следующие проверки:
  * `cppcoreguidelines-pro-bounds-pointer-arithmetic` (какая-то арифметика указателей внутри вектора наверняка возникнет)

Максимальное суммарное количество строк (включая пустые) в файле `vector.hpp` — 400.
Другие файлы менять запрещается.
Полное авторское решение занимает 267.

### Дополнительные требования
* Вместо ключевого слова `noexcept` требуется использовать макрос `VECTOR_NOEXCEPT`, определённый в `vector_config.hpp`.
  Это нужно, чтобы в тестах можно было ловить исключения даже если вы где-то напишите лишний `VECTOR_NOEXCEPT` — тесты могут заменить его на пустое множество и отключить `noexcept` в вашем решении.
  Если вы это забудете, то будет падать сильно больше закрытых тестов.
* Запрещается использовать функции стандартной библиотеки для работы с неинициализированной памятью вроде `std::uninitialized_copy`, `std::destroy`,
  равно как и копировать их реализации откуда-либо.
* Запрещается вызывать `allocate(0)`, равно как и `deallocate(nullptr, 0)`.
  Это **отличие от `operator new`**.
  * Также запрещается использовать любые другие методы аллокатора или `std::allocator_traits`.
    Если они вам потребовались — обсудите с лектором.
* Ваша реализация должна делать минимальное количество операций с аллокатором в каждом конкретном случае.
  * Два выделения/удаления памяти вместо одного или одно вместо нуля — это уже плохо.
  * Если без лишнего выделения памяти не обеспечить строгую гарантию исключений, то можно сделать лишнее выделение.
* В остальном количество операций с `T` должно быть минимально возможным в каждом конкретном случае.
  * Копирование элемента вместо перемещения — это очень плохо.
  * Если есть шанс, что придётся сделать `2*n` перемещений элементов при `resize` — это плохо.
  * Два перемещения вместо одного — это плохо.
  * В частности, делать временные переменные типа `T` наверняка плохо.
  * Удаление элемента и вызов конструктора копирования — это хуже, чем вызвать оператор копирующего присваивания (это потребуется только один раз, там `operator=` гарантированно существует).
  * Если в случае «вектору не требуется перевыделение памяти» или другом можно сделать что-то оптимальнее — это нужно сделать.
* В остальном все операции должны быть асимптотически оптимальны.
* Запрещается анализировать тип `T` для более эффективной работы.
  Например, даже если `T` является trivially copyable, то для присваивания всё ещё требуется вызывать `operator=`, а не `std::memcpy`.

### Закрытые тесты
В этом задании много закрытых тестов.

Открытые тесты гарантированно проверяют лишь корректность сигнатур (за исключением наличия/отсутствия `noexcept` и ref-qualifier)
и работу с минимально возможным (по набору операций) `T`.
Время работы, количество выделений памяти, операций с `T` и гарантии исключений проверяются очень поверхностно.

### Частичные решения
Вы можете реализовать любой префикс из пяти подзаданий ниже и получить частичные баллы.

1. Есть следующие упрощения:
    1. От вас требуется реализовать только операции, помеченные `1` в столбце «Подзадача» [выше](#поддерживаемые-операции).
    2. Не требуется реализовывать rvalue-ref перегрузку для `[]`.
    3. Тип `T` всегда и `DefaultConstructible`, и `CopyConstructible`, и `CopyAssignable`.
    4. Не требуется минимизировать количество операций с `T`.
    5. В копирующем операторе присваивания разрешается всегда делать одно выделение памяти
       независимо от ситуации.
2. Дополнительно требуется реализовать:
    1. Операции, помеченные `2` в столбце «Подзадача».
    2. Rvalue-ref перегрузку для `[]`.
3. Требуется реализовать все оставшиеся операции.
   Упрощения 3-5 из подзадачи 1 всё ещё действуют.
4. Тип `T` может не реализовывать любое подмножество из `DefaultConstructible`, и `CopyConstructible`, и `CopyAssignable`.
   Также требуется минимизировать количество операций с `T` везде, кроме `operator=`.
   Перемещения и копирования пока считаем одинаково дорогой операцией.
   Также каждый метод `vector` может сделать одно лишнее конструирование и один лишний деструктор — можно как раз создать временную переменную.
5. Все упрощения убраны.
   Требуется минимизировать количество операций с `T` вообще везде, включая `operator=`.
   Если какое-то копирование можно заменить на перемещение — это нужно сделать.
   Лишние конструирования и деструкторы запрещены.

## Инструкция по сдаче
[Схема стандартная](../common/#формат-сдачи): вы должны выполнить
задание в отдельной ветке и создать Pull Request.
В этом задании должно хватить веб-интерфейса GitHub, если возникают проблемы — попросите практика помочь.

Если вы хотите сдать только некоторые части задания, закомментируйте соответствующие `#define`
для тестов на подзадания 2-5 в файле `vector_test.cpp`:
`TEST_ADDITIONAL_OPS`, `TEST_EXTEND_OPS`, `TEST_CAREFUL_CONSTRUCTORS`, `TEST_VERY_FORMALLY_EFFICIENT`.

## Система оценки
* Задание оценивается в 10 баллов: 6 за корректность, 4 за стиль.
  * Если не проходит хотя бы одна автопроверка или неверно назван PR, вы получаете ноль.
  * Вы не можете получить за стиль больше баллов, чем за корректность.
* Вы можете сдать любой префикс частей:
  |Выполненные части|Макс. корректность|Макс. стиль|Макс. итог|
  |---|---|---|---|
  |1  |1  |1  |  2|
  |1-2|1.5|1.5|  3|
  |1-3|3  |2  |  5|
  |1-4|6  |4  | 10|
  |1-5|7  |5  | 12|

Баллы свыше 10 в этом задании считаются бонусными.
Вы их набрать можете, а Идеалов Идеал Идеалович — нет.
Итоговая оценка за практику всё ещё не превышает 10.

## Сроки сдачи
Задание выдано 18 мая 2024 (воскресенье).
Ниже в каждом случае указано московское время.

* **Дедлайн сдачи:** 25 мая (воскресенье), **22**:59.
* Ожидаемый срок проверки: 1 июня (воскресенье).
* Если первая попытка сдачи достаточно разумна (на усмотрение принимающего),
  то вы можете сделать ещё попытку исправлений или даже несколько.
    * Предложение актуально даже если вы получили автоматический ноль за первую попытку.
    * Выставляется максимум из всех попыток.
* **Срок исправлений**: **8** июня (воскресенье), **22**:59.
