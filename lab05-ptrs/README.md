# Лабораторная работа №5 (ptrs)

## Содержание

1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Советы](#советы)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Базовые требования](#базовые-требования)
    1. [Дополнительные требования](#дополнительные-требования)
    1. [Семантика умных указателей](#семантика-умных-указателей)
    1. [Поддерживаемые операции](#поддерживаемые-операции)
    1. [Гарантии](#гарантии)
    1. [Частичные решения](#частичные-решения)
1. [Бонусное задание](#бонусное-задание)
1. [Инструкция по сдаче](#инструкция-по-сдаче)
1. [Система оценки](#система-оценки)
1. [Сроки сдачи](#сроки-сдачи)

## Задание
Реализуйте два шаблона класса для умных указателей на `T`: `unique_ptr<T, Deleter>` и `shared_ptr<T>`,
являющиеся упрощениями соответствующих шаблонов из `std::`.
В некоторых тонких местах поведения вашей упрощённой версии и стандартного умного указателя могут отличаться,
уточняйте по условию и у преподавателей.

`unique_ptr` должен быть move-only и уметь использовать произвольный функтор типа `Deleter` для удаления объекта.
Вы также должны самостоятельно реализовать функтор по умолчанию,
похожий на `std::default_delete`, который будет вызывать обычный оператор `delete`.

В `shared_ptr` поддержка произвольных функторов для удаления не требуется.

Не требуются преобразования и сравнения между указателями на разные типы,
между `unique_ptr`/`shared_ptr`, а также поддержка `unique_ptr<T[]>` или `shared_ptr<T[]>`.
Однако требуется поддерживать произвольные incomplete types во всех операциях, которые не приводят к
вызову `delete` и не требуют complete type другим способом.
Точный набор поддерживаемых операций можно проверить через открытые тесты и проверить ниже в задании.

### Советы
* У шаблонов можно задать значение одному из параметров по умолчанию: `template<typename T = int>`.
  Параметры по умолчанию могут зависеть от предыдущих.
* Умный указатель не должен неявно приводиться к `bool`.
  А вот `explicit operator bool` будет в самый раз; некоторые выражения вроде `if (p)` считаются _явным_ приведением к `bool` (но не к `int`).
  Это конкретно для `explicit operator bool` отдельным текстом написано в стандарте.
* У `nullptr` есть свой отдельный тип: `std::nullptr_t` из `<types>`.
  Так можно сделать отдельный конструктор от `nullptr`, известного на этапе компиляции.
* Если вы скомпилируете тесты с `-DTEST_STD_PTRS`, то они протестируют `std::unique_ptr` и `std::shared_ptr` вместо ваших реализаций.
  Тесты должны проходить.
* Используйте `std::exchange` для упрощения кода.
* Очень много логики будет дублироваться. Подумайте, какой метод наиболее общий и через что лучше всё выразить.
  * Будьте осторожны: иногда вы можете так потерять производительность или потребовать лишние свойства у типа `T`.
* Если вы пишете библиотечный код (вроде умных указателей), вам надо думать про много крайних случаев: не все типы копируются, не у всех есть конструктор по умолчанию...
  * При этом мы ещё не умеем писать отдельный код для случаев "тип копируется"/"тип не копируется" и подобных, но в этом задании и не требуется.
    Достаточно того, что неиспользуемые методы у шаблонных структур не инстанцируются.
* Ошибки компиляции обычно возникают не "в шаблоне", а "в конкретном инстанцировании шаблона". Для понимания ошибки важно смотреть, что за инстанцирование: в какой точке и с какими параметрами.
  * Например, если вы видите предупреждение `delete-incomplete`, то обязательно проследите цепочку вызовов и посмотрите, не пытаетесь ли вы (хотя бы теоретически) удалить incomplete type.
    В официальном решении таких предупреждений нет.
* Закомментируйте тесты, начните с тривиальной некорректной реализации `unique_ptr`,
  и двигайтесь от простого к сложному, раскомментируя тесты по очереди.
  * Например, тесты на incomplete type могут не скомпилироваться с первого раза.
* Шаблонные друзья и друзья для шаблонов — отдельная сложная тема.
  Проще всего реализовать нешаблонную функцию-друга (вроде `swap`) прямо внутри шаблонного класса и не разделять объявление с определением.
* Открытые тесты проверяют далеко не всю корректность.
  Например, какие-то хитрые типы `T` и `Deleter`.
* Будьте осторожны с самоприсваиванием: https://isocpp.org/wiki/faq/assignment-operators#self-assignment-what
* `cppcheck` может выдавать предупреждение `copyCtorPointerCopying`.
  Действительно, обычно копировать указатель на объект с dynamic storage duration (то есть на память, выделенную `new`) — плохая идея и
  лучше использовать умный указатель вместо чистого указателя.
  Но в этом задании вы сами пишите умный указатель и, скорее всего, аккуратно подумали про все чистые указатели.
  Так что наверняка ложное срабатывание.
* `g++` может выдавать предупреждение `-Wuse-after-free`: иногда оно по делу (удаляете один и тот же указатель второй раз), но иногда GCC
  заблуждается. Например, он заблуждается на официальном решении в некоторых тестах на `shared_ptr`, поэтому в них это предупреждение отключено.

## Требования к корректности решения
### Базовые требования
Действуют [стандартные требования](../common/), но:

* Максимальное суммарное количество строк (включая пустые) в файлах `.hpp` — 400.
  Полное авторское решение занимает 234.
* У `clang-tidy` отключены следующие проверки:
  * `cppcoreguidelines-owning-memory`
  * `performance-noexcept-move-constructor`
  * `bugprone-unhandled-self-assignment`

### Дополнительные требования
* Вы можете редактировать только существующие файлы `unique_ptr.hpp` и `shared_ptr.hpp`, а также комментировать `#define` в тестах для частичных баллов.
* Запрещается использовать стандартные умные указатели и `std::default_delete`.
* Минимизируйте количество перемещений/копирований/вызовов деструкторов у нетривиальных объектов.
  * Например, вместо принятия по значению может быть выгоднее сделать две перегрузки: одну с const lvalue-ссылкой, другой с rvalue-ссылкой.
* Минимизируйте количество выделений памяти. Например, для `shared_ptr(nullptr)` память выделять не требуется.
* Запрещается создавать глобальные состояние.

### Семантика умных указателей
#### `unique_ptr`
`unique_ptr` либо хранит `nullptr`, либо единолично владеет указателем `T*` на некоторый объект
вместе со своим экземпляром функтора типа `Deleter` для освобождения объекта по этому указателю.
Копирование `unique_ptr` запрещено, перемещение разрешено (moved-from state — `nullptr`, self-move ничего не делает).
В конце жизни или при сбросе указателя `unique_ptr` должен при помощи ровно того же `Deleter` освободить объект, которым владел.
Обратите внимание, что разные `Deleter` могут ожидать разные объекты.

В отличие от `std::unique_ptr`, в этом задании не разрешается вызывать функтор на `nullptr`.

#### `shared_ptr`
Каждый экземпляр `shared_ptr` либо хранит `nullptr`, либо совместно с другими `shared_ptr`
владеет указателем `T*` на некоторый объект.
Копирование и перемещение `shared_ptr` разрешено (moved-from state — `nullptr`, self-move ничего не делает).
Объект удаляется в точности когда больше не остаётся экземпляров `shared_ptr`, владеющих им.

`shared_ptr` могут создаваться и удаляться в любом порядке.
Копирование `shared_ptr` — единственный способ создать разделяемое владение.
Если создаётся два `shared_ptr` от одного и того же чистого указателя, разрешается double free.

### Поддерживаемые операции
Оба умных указателя должны иметь:

* Конструктор по умолчанию.
* Конструктор от `nullptr`.
* Конструктор от указателя, который требуется взять во владение.
* Перемещающий оператор присваивания.
* Перемещающий конструктор.
* Метод `get()` для получения текущего значения указателя.
* Метод `reset()`, сбрасывающий текущий указатель.
* Метод `reset(x)`, передающий владение обычным указателем `x` умному указателю.
* Перегруженные операторы `->` и `*`.
* Свободную функцию `swap()`.
* Оператор приведения к `bool`.
* Операторы `==` и `!=` для сравнения умных указателей одного типа.
  Указатели равны тогда и только тогда когда либо оба указывают на один и тот же объект, либо оба `nullptr`.

`unique_ptr` также должен иметь:

* Конструктор от указателя, который требуется взять во владение, и удаляющего функтора.
* Метод `release()`, "открепляющий" указатель от умного указателя и возвращающий его.
* Удалённые копирующий конструктор и копирующий оператор присваивания.

`shared_ptr` также должен иметь:

* Копирующий оператор присваивания.
* Копирующий конструктор.

Даже если сам указатель константный, то данные, на которые он указывает, могут быть неконстантны
(а можно и `shared_ptr<const int>` сделать).
Вам требуется самостоятельно добавить `[[nodiscard]]` и `explicit`.
Все операции работают за константное время.

### Гарантии
* Тип `T` не является `void`, массивом, ссылкой или функцией.
* Тип `T` будет полным (complete) при выполнении любой из следующих операций над `shared_ptr` или над `unique_ptr` с `Deleter` по умолчанию:
  * Любой оператор присваивания
  * Метод `reset()`
  * Оператор `->`
  * Уничтожение (также тип `T` будет иметь деструктор)
* Для `unique_ptr` с пользовательским `Deleter` полнота `T` гарантируется только при одной операции:
  * Оператор `->`
* Гарантируется, что тип `Deleter` является полным и, помимо `operator(T*)` и деструктора, поддерживает следующие операции:
  * Конструктор по умолчанию, если используется `unique_ptr::unique_ptr()` или `unique_ptr::unique_ptr(T*)`
  * Конструктор копирования или перемещения (в зависимости от ситуации), если экземпляр `Deleter` передаётся в конструктор `unique_ptr`
  * Конструктор перемещения, если `unique_ptr` меняется местами при помощи `swap` или перемещается в новый объект
  * Перемещающий оператор присваивания, если `unique_ptr` меняется местами при помощи `swap` или перемещается в существующий объект
  * Если поддерживается конструктор копирования, то конструктор перемещения тоже доступен и не запрещён (в крайнем случае просто копирует)

### Частичные решения
Вы можете реализовать любой префикс из трёх подзаданий ниже и получить частичные баллы:

1. `unique_ptr` без поддержки произвольного `Deleter`, используйте `delete` напрямую
2. `unique_ptr` целиком
3. `shared_ptr` целиком

Задание 4 является бонусным (см. ниже).

## Бонусное задание
Это задание можно сдавать только если вы выполнили все части основного задания.

У наивной реализации `shared_ptr` имеется проблема в многопоточной среде: он не является
[const-thread-safe](https://bloomberg.github.io/bde-resources/doxygen/bde_api_prod/group__bsldoc__glossary.html#3.1.5).
Пусть есть два независимых объекта `p1` и `p2`, указывающих на некоторый объект `o`.
Тогда сейчас при одновременном копировании `p1` в одном потоке и `p2` в другом произойдёт
одновременное увеличение счётчика ссылок и undefined behavior.
Исправьте проблему.

## Инструкция по сдаче
[Схема стандартная](../common/#формат-сдачи): вы должны выполнить
задание в отдельной ветке своего существующего закрытого репозитория в организации и в нём же создать Pull Request.
Никаких форков!
В этом задании должно хватить веб-интерфейса GitHub, если возникают проблемы — попросите практика помочь.

Если вы хотите сдать только некоторые части задания: отключите соответствующие автотесты,
закомментировав `#define` в `test_utils.hpp`.
По умолчанию там включены все части, включая бонусную.

## Система оценки
[Схема стандартная](../common/#система-оценки), баллы:

|Выполненные части|Макс. корректность|Макс. стиль|Макс. итог|
|---|---|---|---|
|1  |2  |1  |  3|
|1-2|4  |2  |  6|
|1-3|6  |4  | 10|

* Если вы выполнили все части, вы можете получить ещё +1 балл за [бонусное задание](#бонусное-задание), итого 11.

## Сроки сдачи
Задание выдано 4 марта 2025 (вторник).
Ниже в каждом случае указано московское время.

* **Дедлайн сдачи:** 10 марта (понедельник), **22**:59.
* Ожидаемый срок проверки: 17 марта (понедельник).
* Если первая попытка сдачи достаточно разумна (на усмотрение принимающего),
  то вы можете сделать ещё попытку исправлений или даже несколько.
    * Предложение актуально даже если вы получили автоматический ноль за первую попытку.
    * Выставляется максимум из всех попыток.
* **Срок исправлений**: 24 марта (понедельник), **22**:59.
