# Лабораторная работа №10 (calc)

## Содержание

1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Грамматика арифметического выражения](#грамматика-арифметического-выражения)
    1. [Советы](#советы)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Базовые требования](#базовые-требования)
    1. [Дополнительные требования](#дополнительные-требования)
    1. [Интерфейс библиотеки](#интерфейс-библиотеки)
    1. [Ошибки разбора выражения](#ошибки-разбора-выражения)
    1. [Консольное приложение](#консольное-приложение)
    1. [Обработка ошибок](#обработка-ошибок)
    1. [Частичные решения](#частичные-решения)
1. [Инструкция по сдаче](#инструкция-по-сдаче)
1. [Система оценки](#система-оценки)
1. [Сроки сдачи](#сроки-сдачи)

## Задание

Реализуйте на языке Си библиотеку `calc`, позволяющую вычислять значения арифметических выражений с четырьмя операциями, скобками и вызовами функций.
Все промежуточныые и конечные вычисления идут в типе `double`, гарантируется корректность всех промежуточных вычислений.
Пользователь библиотеки может добавлять в выражения функции из Си произвольной [арности](https://ru.wikipedia.org/wiki/%D0%90%D1%80%D0%BD%D0%BE%D1%81%D1%82%D1%8C).
Вы можете ограничить арность сверху константой `CALC_MAX_ARITY`, но функции с трёмя аргументами поддержать обязательно.
Если на вход получено некорректное арифметическое выражение, библиотека должна сообщить о позиции в строке,
где возникла первая ошибка.

Далее реализуйте на языке Си консольное приложение `./calc-cli`, обрабатывающее строчки некоторого файла по отдельности и выводящее результат обработки в другой файл.
Если строчка является корректным арифметическим выражением, результат обработки — результат вычисления с точностью до трёх знаков после запятой.
Если же произошла ошибка, требуется вывести её код и указание на символ, в котором произошла ошибка.

Разбор арифметического выражения должен работать за линейное время.

### Грамматика арифметического выражения
Можно считать, что установлена локаль `C`/`POSIX` или близкая к ним.
В частности, десятичная запятая — это точка, а число парсится или не парсится однозначно.

Гарантируется, что все числа на входе помещаются в тип `double`.

Гарантируется, что на вход библиотеке подаются только символы с кодами от 1 от 127.
В частности, вы можете использовать стандартные функции `isdigit`, `isalpha`, `isspace`.

Между соседними элементами выражения, а также в начале и в конце выражения может идти произвольное количество пробельных символов (`isspace`).
Пробельные символы не могут встречаться внутри чисел или имён функций.
Вот приблизительная LL-грамматика арифметического выражения `<expr-1>`:

* Выражение `<expr-1>` — это последовательность из хотя бы одного `<expr-2>`, разделённая `+` и `-` (операции левоассоциативны).
* Выражение `<expr-2>` — это последовательность из хотя бы одного `<atom>`, разделённая `*` и `/` (операции левоассоциативны).
* `<atom>` — это одно из:
  * `(`, за которой следует выражение `<expr-1>`, за которым следует `)`.
  * `<number>` — значение типа `double`, то есть вещественное число или какое-то из специальных значений.
  * Вызов функции, состоящий из имени функции `<function-name>`, `(`, аргументов функции `<expr-1>`, разделённых `,`, и завершающей `)`.
    Аргументов может быть ноль или больше.
* Число `<number>` начинается либо с цифры, либо с `+`, либо с `-`, либо с `.`.
  Для разбора числа используйте функции из стандартной библиотеки, там сложный формат.
* `<function-name>` — это последовательность из хотя бы одного латинского символа (`isalpha`).

### Советы
* Начните с первых подзаданий. Парсер потребуется только в конце, а до этого хватает разборок с языками Си и C++.
* Функция `sscanf` хороша, но может работать за линейное от размера входа время, даже если надо прочитать всего одно число.
  Воспользуйтесь какой-нибудь другой.
* Для перевыделения памяти в Си используйте `realloc`.
* Вы уже писали парсер арифметических выражений на алгоритмах: контест `200918_hse`, задача 3D.
  * В этом задании наверняка будет проще написать метод рекурсивного спуска (recursive descent), потому что ему не требуется выделять динамический массив
    под стэк операций.
    Пример упрощённого парсера есть в файле `demo-parser.c`.
  * Общая идея метода рекурсивного спуска: напишите функции `read_expr_1`/`read_expr_2`/`read_atom`/`read_number`/..., которые считывают из
    строки максимально длинный префикс, являющийся `<expr-1>`/`<expr-2>`/`<atom>`/`<number>`, соответственно.
    Тогда каждую из этих функций можно реализовать жадным алгоритмом.
    Оказывается, это работает.
* Для использования функций из `<math.h>` под Linux в языке Си иногда требуется явно прилинковать библиотеку `m` (сокращённо от math): `-lm`.
  В `CMakeLists.txt` это уже сделано.
* Компилятор может требовать инициализации всех членов структуры при помощи `{}`, даже если этот член — анонимный `union`.
  Это нормально, вы можете проинициализировать первый член `union` (в том числе анонимного) при помощи тех же `{}`.
  Однако проинициализировать не-первый член `union` так нельзя:
  ```c++
  struct Foo {
      int a;
      union {
          int b;
          float c;
      };
  } f = {1, {2}};  // a=1, b=2, c неактивен и активировать при помощи {} нельзя.
  ```
* Visual Studio считает, что anonymous union — нестандартное расширение языка и иногда выдаёт предупреждение `warning C4201: nonstandard extension used: nameless struct/union`.
  Однако anonymous union (не struct!) поддерживается всеми стандартами C++ и стандартом C99, поэтому это предупреждение следует заглушить, если оно не по делу:
  ```c++
  #ifdef _MSC_VER  // Код внутри #ifdef компилируется только на Visual Studio
  #pragma warning(push)  // Сохранить текущие настройки предупреждений
  #pragma warning(disable : 4201)  // Отключить C4201
  #endif
  // Код, вызывающий предупреждение C4201
  #ifdef _MSC_VER
  #pragma warning(pop)  // Восстановить настройки предупреждений
  #endif
  ```
* Макросной магии в этом задании практически не требуется, максимум для задания констант.
  * В частности, не надо пытаться эмулировать перегрузки по количеству аргументов в Си при помощи макросов.
    Это осуществимо, но не требуется.
    А то [наткнётесь на нестандартное поведение компиляторов](https://stackoverflow.com/q/76193609/767632).
* Если вам захотелось сделать функцию на Си, которая принимает произвольное количество аргументов,
  то вам это не надо.
  В частности, не надо использовать `...` ни в Си (variadic functions), ни в C++ (variadic templates).
* Если clang-tidy выдаёт ошибку `misc-const-correctness` и предлагает добавить `const` к каким-то переменным
  в теле тестов — вероятно, вы слишком много где пометили метод как `mutable`, наверняка не по делу.
  Перепроверьте, в случае чего напишите преподавателю.

## Требования к корректности решения
### Базовые требования
Действуют [стандартные требования](../common/).
Максимальное суммарное количество строк (включая пустые) в файлах `.hpp` и `.cpp` — 500.
Полное авторское решение занимает 395.

Обратите внимание, что для языка Си не запускается `clang-tidy`, который поддерживает только C++.

Помимо этого, `clang-tidy` не запускается на файле `calc.h` (он должен быть совместим с Си) и отключены следующие проверки:

* `cppcoreguidelines-pro-type-union-access`

### Дополнительные требования
* Вы должны проверять абсолютно все коды возврата всех функций, которые могут завершиться с ошибкой, кроме функций вывода на экран или в файл.
* При обработке ошибок запрещается копипастить код для освобождения ресурсов (даже если это простой `fclose`).
  В C++ это делают деструкторы, в Си используйте `goto`.
* Должно проходить три вида автоматических тестов:
  * Тесты на C++ (`calc_test`)
  * Тесты на Си (`calc_test_c`)
  * Тесты консольного приложения (`run-test-data.sh`)
* В консольном приложении запрещается считывать посимвольно.
  В каждой строке допускается `O(log n)` считываний, где `n` — длина строки.

### Интерфейс библиотеки
Заголовочный файл `calc.h` должен корректно работать и в программах на Си, и в программах на C++.
Он предоставляет следующие сущности:

* `CALC_MAX_ARITY` — целочисленная константа, максимальная поддерживаемая арность функций.
* `calc_function` — тип, из которого можно создать массив с определениями функций.
  * Должно быть можно проинициализировать значение этого типа при помощи следующего designated initializer:
    ```c
    {.name = "sqrt", .arity = 1, .func1 = sqrt}
    ```
  * Аналогично с `func1` для функций другой арности есть `func0`, `func2` и так далее.
* `CALC_FUNCTIONS_SENTINEL` — специальное значение типа `calc_function`, обозначающее конец массива функций.
* Семейство констант `CALC_ERROR_*` (смотри описание ниже).
* `calc_result` — тип переменной, в которую библиотека может сохранить значение.
  * Внутри этого типа должно быть доступно минимум два поля:
    * `value` с посчитанным значением
    * `error_position` с позицией, в которой произошла ошибка разбора выражения (смотри ниже).
  * Тип должен занимать как можно меньше байт.
* `calc_evaluate(expr, res, functions)` — функция с трёмя параметрами:
  * `expr` — ASCIIZ-строка (строка в стиле Си, null-terminated string), содержащая арифметическое выражение.
  * `res` — опциональный указатель на переменную типа `calc_result` (то есть может быть равен `nullptr`), в которую будет сохранён результат разбора выражения (если передан не `nullptr`).
  * `functions` — опциональный указатель на массив функций, доступных при вычислении выражения.
  * Функция должна возвращать код ошибки из семейства `CALC_ERROR_*`.

#### Параметр `functions`
* При подключении `calc.h` в C++ функцию `calc_evaluate` должно быть можно вызвать только с первыми двумя параметрами, параметр `functions` должен установиться в `nullptr`.
  * При этом должна сохраниться возможность вызывать `calc_evaluate` с трёмя параметрами.
  * И в языке Си, и в языке C++ должны проверяться типы параметров.
    В частности, нельзя объявить в Си как `void calc_evaluate()`.
  * В языки Си функция `calc_evaluate` всегда вызывается с тремя параметрами.
* Если функции `calc_evaluate` передан нулевой параметр `functions` (либо явно, либо при вызове из C++ в двумя параметрами), то должны быть доступны следующие функции по умолчанию: `sqrt`, `sin`, `cos`, `pow` (из `<math.h>`).
  * Если передан ненулевой параметр, то эти функции недоступны.
* Гарантируется, что набор функций в ненулевом `functions` корректен:
  * Завершается значением `CALC_FUNCTIONS_SENTINEL`.
  * Все имена — корректные непустые ASCIIZ-строки, различны, состоят только из латинских символов.
    * В частности, перегрузок по количеству аргументов тоже нет.
  * Функция ожидает ровно столько параметров типа `double`, сколько указано в `arity`, и возвращает `double`.

### Ошибки разбора выражения
Если при разборе строки произошла ошибка, `calc_evaluate` обязана о ней сообщить, вернув
соответствующий код и указав на первый символ с ошибкой (возможно, `\0` в конце строки, который не считается пробельным).

Возможны следующие ошибки:

| Код | Константа | Описание | Символ с ошибкой |
| --- | --- | --- | --- |
| 0 | `CALC_ERROR_OK` | Ошибок нет | N/A |
| 1 | `CALC_ERROR_BAD_NUMBER` | `<number>` корректно началось с цифры, `+`, `-` или `.`, но не является числом с точки зрения стандартной библиотеки | Первый непробельный символ числа |
| 2 | `CALC_ERROR_UNKNOWN_FUNCTION` | Функция с именем `<function-name>` не существует | Первый символ после имени функции |
| 3 | `CALC_ERROR_EXPECTED_OPEN_PAREN` | Ожидалась круглая скобка при вызове функции | Первый неожиданный непробельный символ |
| 4 | `CALC_ERROR_EXPECTED_COMMA` | Ожидалась запятая при вызове функции | Первый неожиданный непробельный символ |
| 5 | `CALC_ERROR_EXPECTED_CLOSE_PAREN` | Ожидалась закрывающая при вызове функции или разборе `<atom>` | Первый неожиданный непробельный символ |
| 6 | `CALC_ERROR_UNEXPECTED_CHAR` | Неожиданный символ при разборе `<atom>`, но не начало `<number>` (плюс, минус, точка) | Первый неожиданный непробельный символ |
| 7 | `CALC_ERROR_EXTRA_INPUT` | Некоторый префикс строки является корректным выражением, но не вс строка | Первый неожиданный непробельный символ |

Это покрывает все возможные ошибки разбора выражения.
Если вам кажется, что что-то не покрыто — напишите преподавателю.

Ошибки сделаны так, чтобы было удобно написать метод рекурсивного спуска (как в `demo-parser.c`) и выдавать ошибки в тех местах, где он перестаёт понимать происходящее.
В других способах разбора будет удобно выдавать другие ошибки.

### Консольное приложение
Приложение запускается следующей командой:

```
./calc-cli ‹in-file› ‹out-file›
```

Дальше для каждой строчки `in-file` (включая неполную последнюю, при её наличии) в выходной файл выводится одно из:

* Значение вычисленного выражения — если выражение корректно.
  * Используется набор функций по умолчанию.
  * Выводить требуется в виде `xxx.yyy` ровно с трёмя знаками после запятой.
    * Гарантируется, что результатом не будут специальные значения из IEEE-754.
    * Считаем, что округление в стандартной библиотеке везде одинаковое и нас устроит.
* Сообщение об ошибке из трёх строк — если выражение некорректно:
  * `Error 5:`, где `5` — код ошибки.
  * Два пробела и `<expr>` — поданное на вход выражение.
  * Два пробела и `...^` — последовательность из нескольких точек и одного символа `^` в конце, указывающая на символ выражения, где произошла ошибка.

Стандартный поток вывода и стандартный поток ошибок остаются пустыми.

Заранее известных ограничений на размер файла или максимальную глубину выражения нет.
Вы можете считать, что глубины стэка вам хватит.

### Обработка ошибок
При возникновении следующих ошибок приложение обязано выдать в стандартный поток ошибок соответствующее сообщение (формат важен).
Для большинства также должно завершиться с кодом возврата 1.
Для некоторых ошибок, возникающих в начале, выходной файл не должен создаваться.

| Ошибка | Пример сообщения | Комментарий | Завершиться | Выходной файл создан |
| --- | --- | --- | --- | -- |
| Аргументов не ровно два | `Usage: ./calc-cli <input> <output>` | Вместо `./calc-cli` выводите `argv[0]` | Да | Нет |
| Не удалось открыть входной файл | `Unable to open 'a.in' for reading` | Вместо `a.in` выведите имя файла | Да | Нет |
| Не удалось открыть выходной файл | `Unable to open 'a.out' for writing` | Вместо `a.in` выведите имя файла | Да | Нет |
| Не удалось (пере)выделить буфер | `Unable to allocate buffer` | | Нет, пропустить текущую строку | Да |
| Ошибка при чтении из файла | `Error while reading from the input` | | Да | Да |

Если возникла ошибка при вычислении выражения, это не является поводом завершить работу или вернуть 1.

Если не удалось прочитать очередную строчку целиком, то в выходном файле в качестве ответа выводится число ноль.

Это покрывает все возможные ошибки консольного приложения.
Если вам кажется, что что-то не покрыто — напишите преподавателю.

### Частичные решения
Вы можете реализовать любой префикс из пяти подзаданий ниже и получить частичные баллы:

1. Требуется реализовать только библиотеку `calc`, причём со следующими упрощениями:
    1. Пробельные символы во входных данных не встречаются.
    2. Все `<atom>` теперь всегда является `<number>`. То есть нет ни скобок, ни вызовов функций.
       Вам всё ещё требуется поддерживать параметр `functions`, но пользователь не будет создавать
       экземпляры `calc_function` кроме как через `CALC_FUNCTIONS_SENTINEL`.
       То есть `calc_function` может быть хоть псевдонимом для `int`.
    3. `<expr-1>` всегда является либо `<atom>`, либо `<atom><op><atom>`, где `<op>` — одна из четырёх арифметических операций.
       Другими словами, выражение — это либо число, либо два числа с операцией.
    4. Для некорректных выражений вы можете возвращать любой код ошибки кроме `CALC_ERROR_OK`.
       Значение `error_position` может быть произвольным `int`.
2. В выражениях теперь разрешаются функции, но параметры функции всегда являются просто `<number>`.
   То есть всё ещё не требуется никакой рекурсии или стека разбора.
3. Реализуйте ещё и консольное приложение.
   Считайте, что каждая строка входного файла содержит не более 100 символов (за исключением символа перевода строки).
   Так как `error_position` пока неточен, вы можете указывать на любой символ как ошибочный.
4. Выражения теперь могут быть произвольные: с пробельным символами, скобками, вложенными вызовами функций, несколькими операциями подряд с разными приоритетами.
   Также теперь требуется указывать точные коды ошибок и `error_position` для некорректных выражений.
5. Строки входного файла теперь не ограничены.

## Инструкция по сдаче
[Схема стандартная](../common/#формат-сдачи): вы должны выполнить
задание в отдельной ветке своего существующего закрытого репозитория в организации и в нём же создать Pull Request.
Никаких форков!
В этом задании должно хватить веб-интерфейса GitHub, если возникают проблемы — попросите практика помочь.

Если вы хотите сдать только некоторые части задания, закомментируйте соответствующие `#define` в файле `tests_config.hpp`.

## Система оценки
[Схема стандартная](../common/#система-оценки), баллы:

|Выполненные части|Макс. корректность|Макс. стиль|Макс. итог|
|---|---|---|---|
|1  |1.5|0.5| 2|
|1-2|2  |1  | 3|
|1-3|3  |2  | 5|
|1-4|5  |3  | 8|
|1-5|6  |4  | 10|

## Сроки сдачи
Задание выдано 21 апреля 2025 (понедельник). 
Ниже в каждом случае указано московское время.

* **Дедлайн сдачи:** 27 апреля (воскресенье), **22**:59.
* Ожидаемый срок проверки: 4 мая (воскресенье).
* Если первая попытка сдачи достаточно разумна (на усмотрение принимающего),
  то вы можете сделать ещё попытку исправлений или даже несколько.
    * Предложение актуально даже если вы получили автоматический ноль за первую попытку.
    * Выставляется максимум из всех попыток.
* **Срок исправлений**: 11 мая (воскресенье), **22**:59.
