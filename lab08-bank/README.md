# Лабораторная работа №8 (bank)

## Содержание

1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Советы](#советы)
    1. [Лирическое отступление](#лирическое-отступление)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Базовые требования](#базовые-требования)
    1. [Дополнительные требования](#дополнительные-требования)
    1. [Гроссбух](#гроссбух)
    1. [Блокирующий итератор](#блокирующий-итератор)
    1. [Сетевой сервер](#сетевой-сервер)
1. [Бонусное задание](#бонусное-задание)
1. [Инструкция по сдаче](#инструкция-по-сдаче)
1. [Система оценки](#система-оценки)
1. [Сроки сдачи](#сроки-сдачи)

## Задание
Это задание состоит из трёх частей, вы можете выполнить только префикс и [получить частичные баллы](#система-оценки).

1. **Гроссбух**.
   Напишите потокобезопасные (const-thread safe) классы `bank::ledger` (гроссбух), `bank::user`, `bank::transaction`, представляющие игрушечный банк.
   Каждый пользователь:
    * Имеет уникальное имя.
    * Может получить свой текущий баланс в валюте `XTS` и историю транзакций.
    * Создаётся в момент первого обращения и получает 100 XTS (это такая [тестовая валюта из ISO 4217](https://en.wiktionary.org/wiki/XTS)).
    * Может перевести любому другому пользователю валюту.
    * Если при переводе возникает логическая ошибка,
      выбрасывается исключение-наследник `bank::transfer_error` с детальным `what()` и состояние гроссбуха не меняется.
2. **Блокирующий итератор**.
   Добавьте возможность потокобезопасно отслеживать транзакции пользователя в блокирующем режиме при помощи класса `bank::user_transactions_iterator`:
    * Метод `wait_next_transaction()` блокируется до появления очередной транзакции у пользователя и возвращает её.
    * Должна быть возможность за одну атомарную операцию посмотреть на текущее состояние пользователя и создать `bank::user_transactions_iterator`.
      В противном случае некоторые транзакции могут потеряться между чтением состояния и созданием итератора.
3. **Сетевой сервер**.
   Напишите TCP-сервер, который создаёт один гроссбух и позволяет TCP-клиентам побыть пользователями банка
   через протокол с состоянием ([stateful protocol](https://en.wikipedia.org/w/index.php?title=Stateful_protocol&redirect=no)):
    * Каждый TCP-клиент подключается как один из пользователей и действует от его имени.
    * Поддерживаются все методы класса `bank::user`, а также сообщения об ошибках.
    * Используйте `boost::asio::ip::tcp::iostream` для блокирующего взаимодействия с сетью.
    * TCP-клиенты могут в любой момент подключаться и отключаться, один пользователь может управляться одновременно несколькими клиентами.

Точные поддерживаемые методы смотрите в тестах, а тонкости их семантики — в требованиях ниже.

### Советы
* Выполняйте части сверху вниз.
  * В первой части (гроссбух) вам потребуются только `std::mutex` и `std::unique_lock`/`std::scoped_lock`.
  * Во второй части (блокирующий итератор) добавится `std::condition_variable`.
  * В третьей части добавится `std::thread` и `boost::asio::ip::tcp`.
* Чётко распишите, что у вас защищено какими мьютексами и за какие условия отвечает условная переменная.
* Будьте осторожны с deadlock'ами, их очень просто получить при переводе денег от пользователя к пользователю.
* Не рассчитывайте, что выданные автотесты поймают все многопоточные проблемы.
* Воспользуйтесь thread sanitizer или helgrind.
  * Осторожно: они могут ложно ругаться на разный порядок блокировки мьютексов или куски стандартной библиотеки.
  * Ругань на разный порядок блокировки мьютексов можно подавить, передав при запуске параметр `--track-lockorders=no`.
* Если пишите свои автотесты — делайте их большими и с кучей потоков, которые пытаются одновременно и писать, и читать один и тот же ресурс.
* Для отладки сетевого сервера используйте `netcat`.
* Обратите внимание, что блокировка мьютекса не `noexcept`.
* Помните, что для корректного общения с TCP-клиентом необходимо сбрасывать буфер
  и регулярно проверять, корректны ли потоки ввода-вывода (вдруг клиент отключился).
* Если класс `bank::ledger` скучный — развлекитесь с `emplace_hint` и `piecewise_construct`.
* Осторожно: [`boost::asio::ip::tcp::iostream` может быть не movable конкретно под Clang](https://github.com/chriskohlhoff/asio/issues/997).
* Может пригодиться конструкция: `friend struct Bar;` внутри структуры `Foo` делает
  всю структуру `Bar` целиком другом `Foo`.
  В частности, все методы и поля `Bar` получают доступ к приватным полям и методам `Foo`.
* Может пригодиться конструкция: `const T*` означает "неконстантный указатель на константный `T`",
  а вот `T *const` означает "константный указатель на неконстантный `T`".

### Лирическое отступление
* Операции чтения в многопоточных программах редки, но тут они есть из учебных соображений.
  * Например, если мы прочитали баланс пользователя при помощи `.balance_xts()`, то мы не можем эти данные никак использовать: баланс мог только что измениться в другом потоке.
  * Аналогичная проблема есть и с методом `.monitor()`: мы не знаем, с какого момента мы реально начали следить за транзакциями.
  * Поэтому обычно требуются более высокоуровневые сложные методы вроде `snapshot_transactions`.
* Так как деньги могут измеряться по-разному, ко всем методам и переменным дописан суффикс — единица измерения `_xts`.
  * Здесь одна единица измерения и запутаться сложно, но в более сложных программах это важнее.
    Например: `timeout_millis`, `timeout_micros`, `timeout_ms` (милли или микро?), `timeout_sec`.
* Автоматические тесты на многопоточность написаны немного коряво:
  * Из не-главного потока никогда не вызываются `CHECK`/`REQUIRE`, несмотря на то, что `doctest` потокобезопасен.
    Вместо этого данные только собираются, а проверяются уже в главном потоке.
  * Это сделано, чтобы можно было запускать автотесты под MinGW.
    Там нужная конструкция `thread_local` плохо работает последние лет десять (то есть всегда),
    из-за чего doctest (и другие библиотеки) [могут падать под отладчиком](https://github.com/onqtam/doctest/issues/501#issuecomment-827577621).
* Было бы здорово научиться выходить из команды `monitor` в сервере, но мы так сделать без извращений не можем:
  у нас и ввод-вывод через `tcp::iostream` блокирующий (но это полбеды), и итератор блокирующий (это вторые полбеды).
  То есть мы не можем одной операций ждать либо команды, либо очередной транзакции, обязаны выбирать.
  * В целом можно было бы заводить на команду `monitor` второй поток, который будет ждать транзакций, и третий поток,
    который преобразует блокирующий итератор в неблокирующий... Но мы так делать не будем.

## Требования к корректности решения
### Базовые требования
Действуют [стандартные требования](../common/).
Обратите внимание, что состояние гонки (race condition) — UB и запрещается, даже если не стреляет.

Максимальное суммарное количество строк (включая пустые) в файлах `.hpp` и `.cpp` — 500.
Полное авторское решение занимает 403.

При запуске под Valgrind решение компилируется с флагом `-DEXPECT_VALGRIND`, чтобы тесты стали чуть поменьше.
При запуске под Address Sanitizer под Linux (но не под macOS) решение компилируется с флагом `-DEXPECT_ASAN`,
чтобы один конкретный тест стал поменьше и не требовал много памяти на проверяющей машине.

### Дополнительные требования
* Если несколько потоков работают с непересекающимися подмножествами заранее созданных пользователей, они не должны друг другу мешать.
    * В частности, создать один глобальный мьютекс на все операции со всеми пользователями не прокатит.
    * А если один поток создаёт нового пользователя, то другие в это время не имеют права обращаться к гроссбуху.
* Запрещается использовать блокирующий ввод-вывод под мьютексом — он может зависнуть на неопределённое время.
    * Подсказка: осторожно со `snapshot_transactions`.
* Разные виды исключений должны иметь разные классы.
* Запрещается изменять `CMakeLists.txt` и/или добавлять новые файлы.
  Если очень надо — обсудите с преподавателем.

#### Запрещённые приёмы
Нарушение любого из требований ниже обнуляет баллы в соответствующей части и зависящих от неё.

* Запрещено костылить синхронизацию потоков через `std::this_thread::sleep_for` и похожие трюки.
* Блокирующий итератор должен, как правило, использовать блокирующее ожидание (например, через условную переменную), а не активное.

### Гроссбух
Экземпляр класа `bank::ledger` владеет пользователями соответствующего гроссбуха.
Метод `get_or_create_user(name)` атомарно возвращает ссылку на пользователя `name`,
которая валидна, пока живёт гроссбух.
Если этого пользователя ещё не было, то он добавляется в гроссбух.
Пользователи в памяти не перемещаются, так что можно использовать указатель на пользователя как идентификатор.

Каждый пользователь может сообщить потокобезопасно и за константное время:
* Своё имя: `.name()`
* Текущий баланс: `.balance_xts()`, помещается в `int` и неотрицателен.

Также должна быть возможность потокобезопасно посмотреть на часть транзакций пользователя, не копируя их все.
Для этого метод `.snapshot_transactions(f)` принимает функтор `f` и вызывает его под мьютексом,
передав в качестве параметров транзакции и текущий баланс.
Так можно прочитать любую часть транзакций без вмешательства со стороны остальных потоков.
Баланс нужно передавать, чтобы `f` мог его узнать за константное время без вызова `.balance_xts()` (иначе потребуется reentrant mutex).

Вы можете хранить транзакции и передавать их параметру `snapshot_transactions(f)`
в произвольном последовательном контейнере.
Старые транзакции идут в начале.
Транзакция должна представляться структурой `bank::transaction` с константными публичными полями:
* `counterparty` — указатель на пользователя-вторую сторону транзакции или `nullptr`,
  если эта сторона — сам банк (при исходном зачислении денег).
* `balance_delta_xts` — на сколько изменился баланс пользователя от транзакции.
* `comment` — произвольный комментарий к транзакции.

Метод `.transfer(counterparty, amount_xts, comment)` у пользователя `user`
атомарно переводит `amount_xts` XTS пользователю `counterparty`.
После этого у каждого пользователя должна появиться ровно одна новая транзакция.
Если это сделать невозможно — должно вылететь исключение-наследник класса `bank::transfer_error`
с подробностями.
Если `user` не хватает денег, то должно вылететь исключение `bank::not_enough_funds_error`
с фиксированным сообщением (смотри тесты).
Это не единственная возможная при переводе ошибка, остальные вам надо сообразить самостоятельно
исходя из здравого смысла и требований задания.

### Блокирующий итератор
Метод `snapshot_transactions(f)` теперь, помимо доступа к транзакциям, атомарно возвращает
экземпляр класса `user_transactions_iterator`.

Этот итератор имеет единственный метод `wait_next_transaction`, который возвращает
очередную транзакцию, которая не попала в `snapshot_transactions`.
Если такой транзакции ещё не случилось, то блокируется, пока она не появится.
Так как `snapshot_transactions()` работает атомарно, это позволяет любому потоку
полностью знать состояние любого пользователя.
Внутри `snapshot_transactions` можно посмотреть на все транзакции до некоторого момента
(вызова `snapshot_transactions`),
а итератор позволяет посмотреть на все транзакции после этого момента.

Может существовать несколько независимых итераторов одновременно.

Также к `bank::user` добавляется метод `monitor()`, который просто возвращает итератор,
позволяющий смотреть на все транзакции с момента вызова `monitor()`.
Он используется в некоторых тестах, но вообще [является плохим API](#лирическое-отступление).

### Сетевой сервер
Консольное приложение запускается так:

```
./bank-server <port> <port-file>
```

При запуске сразу создаётся TCP-сервер на порту `<port>`.
`<port>` может быть равен нулю, это так и надо передать в конструктор `tcp::endpoint`,
тогда `tcp::acceptor` выберет случайный свободный порт — это удобно для автоматического
тестирования нескольких решений на одной машине параллельно.
Выбранный порт сервера требуется сохранить в файл `<port-file>`.
Если не удалось — выведите в стандартный поток ошибок сообщение `Unable to store port to file <port-file>`.

Сервер создает себе один глобальный гроссбух, с которым работают все клиенты.
Банковские пользователи из него никогда не удаляются и не пересоздаются.
Сервер может пользоваться только описанными в задании публичными методами классов.

Все сообщения сервера выводятся в стандартный поток ввода, сбрасывать буфер после очередного сообщения обязательно:

* В начале работы выведите сообщение `Listening at <endpoint>`,
  где `<endpoint>` — `acceptor.local_endpoint()`, где доступен сервер локально.
* При подключении клиента выведите сообщение `Connected <remote> --> <local>`,
  где `<remote>` и `<local>` — `remote_endpoint()` и `local_endpoint()` для клиента, соответственно.
  `local_endpoint()` будет частным случаем `acceptor.local_endpoint()`.
* При отключении клиента (по любой причине) выведите аналогичное `Disconnected <remote> --> <local>`.

Все TCP-клиенты обрабатываются параллельно в разных потоках.
Если какой-то клиент отключается, с остальными ничего не происходит.
Все ответы сервера завершаются переводом строки.
Каждому клиенту соответствует один банковский пользователь,
имена всех пользователей непустые и состоят из символов с кодами 33-127.
С каждомым пользователем может работать несколько клиентов одновременно.
Сессия с каждым клиентом начинается с авторизации пользователя:

* Сервер: `What is your name?\n`.
* Клиент: `<username>` и пробельный символ.
* Сервер: `Hi <username>\n`.

Дальше сервер ожидает команд от клиента.
Команды отделяются друг от друга и аргументов пробельными символами:

* `balance`.
  Ответ — одно целое число (текущий баланс пользователя) и перевод строки.
* `transactions <n>`.
  Ответ — `n` последних транзакций пользователя на `n+2` строках.
  * Точный формат смотрите в тесте `run-test-server.py`.
  * Ячейки в строчке таблицы разделяются одним символом табуляции.
  * Гарантируется, что `<n>` неотрицательно и помещается в `int`.
  * Если транзакций меньше `n`, то выводятся все транзакции пользователя.
* `monitor <n>`.
  Аналогично `transactions <n>`, но после последней транзакции
  сервер не ждёт следующую команду, а начинает бесконечно выводить поток транзакций
  пользователя.
  * Это позволяет "в реальном времени" следить за своими транзакциями.
  * Из этой команды нельзя выйти.
    Более того, для упрощения не требуется при отключении клиента немедленно выводить сообщение `Disconnected`.
* `transfer <counterparty> <amount> <comment>` — перевод пользователю `<counterparty>`.
  * Между `<amount>` и `<comment>` имеется ровно один пробельный символ,
    `<comment>` непусто и завершается `\n`.
  * В частности, `<comment>` может содержать пробелы: `transfer Bob 100 Some real comment`.
  * Ответ — `OK\n` в случае успешного перевода или сообщение об ошибке из `.what()` с переводом строки,
    если перевод неуспешен.
  * Так как сервер может пользоваться только публичными методами, если пользователя `<counterparty>` не существовало,
    он создаётся автоматически в соответствии с поведением метода `get_or_create_user`.
* Любая другая команда. Ответ — `Unknown command: '<введённая-команда>'\n`.
  * Например, если пользователь ввёл `hello world\n`, то это трактуется как две неизвестные команды: `hello` и `world`.

Считаем, что если название команды введено правильно, то все параметры команды также будут корректны.
Однако соединение с клиентом всё ещё может разорваться в любой момент.
Также считаем, что в корректной реализации в любой момент времени баланс любого пользователя помещается в `int`.

## Бонусное задание
Это задание можно сдавать только если вы выполнили все части основного задания.

Используйте вместо обычных мьютексов [`std::shared_mutex`](https://en.cppreference.com/w/cpp/thread/shared_mutex),
чтобы разрешить нескольким потокам одновременно читать константные данные.
Например, это может быть ускорением, если к одному пользователю постоянно обращаются
на чтение, а записи редки.
В этом задании это сомнительный сценарий, но в других многопоточных приложениях может встретиться.

## Инструкция по сдаче
[Схема стандартная](../common/#формат-сдачи): вы должны выполнить
задание в отдельной ветке своего существующего закрытого репозитория в организации и в нём же создать Pull Request.
Никаких форков!
В этом задании должно хватить веб-интерфейса GitHub, если возникают проблемы — попросите практика помочь.

Если вы хотите сдать только некоторые части задания, закомментируйте соответствующие `#define` в файле `test_utils.hpp`.

## Система оценки
[Схема стандартная](../common/#система-оценки), баллы:

|Выполненные части|Макс. корректность|Макс. стиль|Макс. итог|
|---|---|---|---|
|1  |2  |2  | 4|
|1-2|4  |3  | 7|
|1-3|6  |4  |10|

* Вы получаете ноль за часть и связанные с ней, если используете [запрещённые приёмы](#запрещённые-приёмы).
* Если вы выполнили все части, вы можете получить ещё +1 балл за [бонусное задание](#бонусное-задание), итого 11.

## Сроки сдачи
Задание выдано 26 февраля 2025 (среда).
Ниже в каждом случае указано московское время.

* **Дедлайн сдачи:** 3 марта (понедельник), **22**:59.
* Ожидаемый срок проверки: 10 марта (понедельник).
* Если первая попытка сдачи достаточно разумна (на усмотрение принимающего),
  то вы можете сделать ещё попытку исправлений или даже несколько.
    * Предложение актуально даже если вы получили автоматический ноль за первую попытку.
    * Выставляется максимум из всех попыток.
* **Срок исправлений**: **17** марта (понедельник), **22**:59.
