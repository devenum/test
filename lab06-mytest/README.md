# Лабораторная работа №6 (mytest)

## Содержание

1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Советы](#советы)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Базовые требования](#базовые-требования)
    1. [Дополнительные требования](#дополнительные-требования)
    1. [`CHECK` и `CHECK_MESSAGE`](#check-и-check_message)
    1. [`TEST_CASE_REGISTER`](#test_case_register)
    1. [`TEST_CASE`](#test_case)
    1. [`SUBCASE`](#subcase)
    1. [Частичные решения](#частичные-решения)
1. [Инструкция по сдаче](#инструкция-по-сдаче)
1. [Система оценки](#система-оценки)
1. [Сроки сдачи](#сроки-сдачи)

## Задание
Реализуйте библиотеку `mytest` для написания юнит-тестов вроде [doctest](https://github.com/doctest/doctest).
Должны поддерживаться макросы `TEST_CASE`, `CHECK`, `CHECK_MESSAGE` и `SUBCASE`.
Также в одной из подзадач (и только в ней) должен поддерживаться вспомогательный макрос `TEST_CASE_REGISTER` (см. ниже).

Каждый `TEST_CASE` считается пройденным тогда и только тогда, когда все условия `CHECK`/`CHECK_MESSAGE`,
выполненные из него, оказались истинны.

Библиотека состоит из:

* Заголовочного файла `mytest.hpp`, который используется пользователем библиотеки.
* Единицы трансляции `mytest.cpp`, которая всегда подключается пользователем библиотеки и
  содержит нужные определения.
* Единицы трансляции `mytest_main.cpp` с реализацией `int main()`.
  Она подключается пользователем библиотеки только если хочется запускать тесты.
* Заголовочного файла `mytest_internal.hpp`, который используется только для общения
  между собой `mytest.cpp` и `mytest_main.cpp`.
  Например, если они оба используют функцию `X()`, которая не нужна в `mytest.hpp`,
  её стоит объявить именно в `mytest_internal.hpp`.

Должны корректно компилироваться и компоноваться (линковаться) три вида программ,
использующих `mytest`.

* Содержащие `TEST_CASE_REGISTER`: только подходящие под условие конкретной подзадачи.
* Включающие единицы трансляции `mytest_main.cpp` и `mytest.cpp` — в этом случае запускаются все тесты.
* Не включающие единицу трансляции `mytest_main.cpp`, но включающие `mytest.cpp` — в этом случае
  должен запускаться предоставленный пользователем `main()`, а весь код внутри всех `TEST_CASE`
  игнорируется.

Таким образом, пользователь `mytest` может писать тесты вперемешку со своим основным кодом
и они не будут ему мешать.

Можно считать, что программа однопоточная.

Использовать `doctest` запрещается.

### Советы
* Если вы скачиваете под Windows, а запускаете под WSL, то примените `dos2unix` не только к `run-test-data.sh`,
  но и к `detect-compiler.sh` и `tests.txt`.
  А также ко всем тестам, например, командой в Bash: `find . -iname '*.sol' | xargs dos2unix`.
* `clang-tidy` запрещает использовать макросы, однако они требуются в `mytest.hpp`.
  Также иногда возможны ложноположительные срабатывания в заголовках; например,
  на неиспользуемые поля.
  Это нужно заглушить.
* Чтобы не дублировать много кода между `CHECK` и `CHECK_MESSAGE`, создайте вспомогательную
  функцию и гляньте на `std::optional`.
* Так как автотестам требуется компилировать ваше решение, они пытаются найти компилятор при помощи `detect-compiler.sh`.
  Если не получилось сразу, то вы можете:
  * Запустить автотесты из `Developer Command Prompt for VS 2022`, если используете только Visual Studio.
    Должен появиться компилятор `cl.exe`.
  * Скомпилировать каждый из примеров самостоятельно в файл `mytest-main` в соответствующей папке,
    закомментировать в `run-test_data.sh` строчку с запуском `${SIMPLE_COMPILATION_COMMAND[@]} $SOURCES` (комментарии в Bash — `#` в начале строки)
    и запустить автотесты.
* Будьте аккуратны с именами в макросах: по возможности используйте полностью квалифицированные
  имена: `::mytest::foo()` вместо `foo()`.
* Чтобы правильно реализовать макрос `TEST_CASE_REGISTER`, используйте идеи и код из упражнения `macro-execute-before-main`.
* Чтобы правильно реализовать макрос `TEST_CASE`, используйте идеи и код из упражнений `macro-execute-before-main`, `static-keyword`, `siof`
  Иначе может произойти коллизия имён.
* Стандарт [гарантирует](https://en.cppreference.com/w/cpp/language/constant_initialization), что если глобальная переменная инициализируется константой (`int x = 10`), то
  это происходит во всех единицах трансляции строго до всех остальных инициализаций.
  В частности, до вызовов всех необычных конструкторов.
* Если получаете предупреждение `cppcoreguidelines-avoid-non-const-global-variables` внутри макроса и не можете заглушить — просто сделайте соответствующую
  переменную константной.
* Если вам надо сохранить свободную функцию или лямбда-функцию (не метод) в переменную, воспользуйтесь
  `std::function<void()>` (если функция ничего не принимает и не возвращает).
  * Более эффективный и сложный способ для свободных функций (но не лямбд с захватами) — указатели на функции.
  * Шаблоны в этом задании не нужны.
* Чтобы реализовать вложенные `SUBCASE`, вам потребуется как-то узнать о завершении подтеста.
  Для этого вы можете создать внутри `for`/`while` (или даже `if`, начиная с C++17)
  временную переменную с __деструктором__ — специальной функцией, которая вызывается при удалении переменной:
  ```c++
  struct Foo {
      Foo() { std::cout << "Created!\n"; }
      ~Foo() { std::cout << "Destroyed!\n"; }
      // Требуется для clang-tidy
      Foo(const Foo &) = delete;
      Foo(Foo &&) = delete;
      Foo &operator=(const Foo &) = delete;
      Foo &operator=(Foo &&) = delete;
  };
  // ...
  if (Foo f; 2 * 2 == 4) {  // Created!
      std::cout << "inside\n";
  }  // Destroyed!
  ```
* При реализации `SUBCASE` вы не сможете сначала сохранить иерархию куда-то, а потом выполнять.
  Вам надо с первого же запуска `TEST_CASE` начать одновременно выполнять правильный первый `SUBCASE`
  и понимать, что делать дальше.
* К сожалению, Visual Studio может не обработать конструкцию `[[maybe_unused]] ::mytest::Foo foo;`.
  Можно переписать: `::mytest::Foo foo [[maybe_unused]];`.
* Вы можете попробовать понять, что происходит в doctest.
  Рекомендуется пользоваться отладчиком или хотя бы средой разработки, чтобы можно было ходить по определениям.
* Если вам кажется, что с макросами происходит что-то не то — запустите только препроцессор, чтобы посмотреть,
  во что они раскрываются в каждой единице трансляции.
  * Ключ `-E` для gcc/clang.
  * Ключ `/P` для Visual Studio, в GUI называется `Preprocess to a file`.

## Требования к корректности решения
### Базовые требования
Действуют [стандартные требования](../common/), но:

* Максимальное суммарное количество строк (включая пустые) в файлах `.hpp` и `.cpp` — 400.
  Полное авторское решение занимает 252.

### Дополнительные требования
* Все определения должны быть по максимуму вынесены в `mytest_main.cpp` и в `mytest.cpp`.
* В `mytest.hpp` остаётся только самый минимум, который нужен пользователю библиотеки.
  Общие для `mytest.cpp`/`mytest_main.cpp` объявления можно вынести в `mytest_internal.hpp`.
* Любые `*.cpp` запрещено инклудить в другие.
* `mytest_internal.hpp` запрещено инклудить в пользовательскую программу даже косвенно.
  В частности, запрещено инклудить в `mytest.h`.
* Все сущности библиотеки должны находиться внутри пространства имён `::mytest`.
* Так как макросы не могут находиться внутри пространства имён, все внутренние для библиотеки
  макросы должны начинаться с `MYTEST_INTERNAL_`.
* Имена всех сущностей, генерируемых макросами, должны начинаться с `mytest_`.
* Запрещается использовать `__COUNTER__` — это нестандартное расширение.
  Можно использовать `__LINE__`

### `CHECK` и `CHECK_MESSAGE`
Макрос `CHECK(expr)` вычисляет выражение `expr` ровно один раз.
Если получилось истинное значение, ничего не происходит.
Иначе в стандартный поток ошибок (`std::cerr`) выводится сообщение в следующем формате,
содержащее строковое представление `expr`, имя файла и строку,
где располагался вызов `CHECK`:

```
CHECK(2 * 2 == 5) at demo/demo1.cpp:8 failed!
```

Допускается выводить полный путь к файлу, не требуется как-то обрабатывать результат подстановки `__FILE__`.

Макрос `CHECK_MESSAGE(expr, msg)` ведёт себя аналогично, но в сообщении
об ошибке также добавляется сообщение `msg` (это строка, необязательно литерал):

```
CHECK(2 * 2 == 5) at demo/demo2.cpp:13 failed!
    message: demo2-msg2
```

Выражение `msg` тоже должно всегда вычисляться ровно один раз.

* Оба макроса должны вести себя как вызов функции, возвращающей `void`.
* Если программа компилируется в режиме запуска тестов, то оба макроса будут вызываться только при выполнении очередного `TEST_CASE`.
* Если программа компилируется в режиме запуска пользовательского `main()`, то оба макроса могут вызываться вне выполнений `TEST_CASE`.
  * [Extra reading](https://github.com/Nekrolm/ubbook/blob/master/runtime/static_initialization_order_fiasco.md#initialization-order-fiasco-%D0%B8-%D0%BD%D0%B5%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D0%BC%D1%8B%D0%B5-%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%B8): при этом гарантируется, что стандартный ввод-вывод будет проинициализирован до вызова макроса.
* Ни один макрос никогда не прерывает выполнение программы.

### `TEST_CASE_REGISTER`
Этот макрос — упрощённая версия `TEST_CASE`, который позволяет создавать тесты следующим образом.

```c++
// Сначала объявляется или определяется свободная
// функция без аргументов, возвращающая `void`.
void some_test_case() {
    // Тело теста
}
// Сразу после этого пользователь обязан
// "зарегистрировать" эту функцию как тест.
TEST_CASE_REGISTER(some_test_case, "Some test case");
```

Такой макрос реализовать чуть проще, чем `TEST_CASE`.
В doctest прямого аналога нет.

* `name` — произвольный строковой литерал.
* Если в программе встречается хотя бы один вызов `TEST_CASE_REGISTER`, то она целиком подходит под условие одной конкретной подзадачи, где разрешён этот макрос.
  * В частности, вам не нужно уметь обрабатывать `TEST_CASE_REGISTER` и `TEST_CASE` из следущих подзадач вперемешку.
  * Также не нужно уметь обрабатывать `TEST_CASE_REGISTER` без `mytest_main.cpp`.
* Тело теста может вызывать произвольные функции, которые могут пользоваться любыми другими макросами фреймворка.
* В одной строчке файла не может встретиться два `TEST_CASE_REGISTER`.
* Если тесты пройдены, `mytest_main.cpp` должен завершаться с нулевым кодом возврата, иначе — с кодом возврата 1.

Перед началом тестирования каждого теста в стандартный поток ошибок выводится сообщение
с именем теста:

```
Running "Demo1.cpp test case 1"...
```

После окончания всех тестов выводится статистика по количеству пройденных и запущенных тестов:

```
===== Tests passed: 2/5 =====
```

### `TEST_CASE`
После макроса `TEST_CASE(name)` обязательно идут фигурные скобки с текстом теста.
Он может встретиться только там, где может встретиться определение свободной функции.

* Требования к `name` и телу теста такие же, как для `TEST_CASE_REGISTER`.
* Фреймворк не должен требовать от пользователя как-то определять тесты, кроме как `TEST_CASE`.
* Если в программе встречается хотя бы один вызов `TEST_CASE`, то не может встречаться `TEST_CASE_REGISTER`.
* В одной строчке файла не может встретиться два `TEST_CASE`.
* Тесты должны выполняться в лексикографическом порядке: отсортированы по имени теста.
  При совпадении имён порядок произвольный.

### `SUBCASE`
Внутри `TEST_CASE` можно выделять несколько блоков `SUBCASE(name)`, в том числе вложенных,
в том числе внутри функций, которые вызывает `TEST_CASE`.
Выполняются почти [так же, как и в `doctest`](https://github.com/doctest/doctest/blob/86892fc480f80fb57d9a3926cb506c0e974489d8/doc/markdown/tutorial.md#test-cases-and-subcases).

* Трактуем `SUBCASE(name)` как предложение (statement) вроде `if`/`for`, причём
  после него гарантированно идут фигурные скобки с телом подслучая.
* `name` — произвольная строка. Необязательно литерал, может генерироваться динамически.
* В одной строчке файла не может встретиться два `SUBCASE`.
* Можно считать, что максимальная вложенность `SUBCASE` небольшая.

Неформально говоря, мы хотим запустить `TEST_CASE` столько раз, сколько там существует самых глубоких подслучаев.
При каждом запуске обрабатывается новый подслучай.

Более формально, блоки `SUBCASE` выполняются следующим образом.

1. Строится упорядоченный список `X` из `SUBCASE`, внутри которых нет других `SUBCASE`.
   Порядок — как при выполнении программы.
   Например, цикл может сгенерировать несколько разных `SUBCASE`.
2. Каждый случай `x` из `X` выполняется, причём при выполнении случая `x`
   также выполняются те, в которые он вложен.
   * Между запусками случаев выводите в стандартный поток ошибок сообщение:
     ```
     ...another subcase...
     ```
3. Если в какой-то момент `CHECK`/`CHECK_MESSAGE` выдали ошибку,
   то текущий случай обрабатывается до конца, а вот следующие случаи из списка `X` не выполняются.

Например, в следующем коде:

```c++
TEST_CASE("Subcase test") {
    std::cerr << "1";
    SUBCASE("a") {
        std::cerr << "2";
        SUBCASE("b") {
            std::cerr << "3";
        }
        SUBCASE("c") {
            std::cerr << "4";
        }
        std::cerr << "5";
    }
    std::cerr << "6";
    SUBCASE("d") {
        std::cerr << "7";
        SUBCASE("e") {
            std::cerr << "8";
        }
        SUBCASE("f") {
            std::cerr << "9";
        }
    }
    std::cerr << "end\n";
}
```

будет построен список `X` из `SUBCASE("b")`, `SUBCASE("c")`, `SUBCASE("e")`, `SUBCASE("f")`.
При выполнении каждого из них также запустится окружающий код `SUBCASE("a")` или `SUBCASE("d")`.
На экран выведется `12356end` для первого (`a`, `b`), `12456end` для второго (`a`, `c`),
`1678end` для третьего (`d`, `e`) и `1679end` для четвёртого (`d`, `f`).

А если в примере выше после `std::cerr << "2"` добавить `CHECK(false)`,
то будет запущен только один подслучай (`a`, `b`) и на экран выведется `12356end`.

Также `CHECK` и `CHECK_MESSAGE` при ошибке должны выводить на экран и
путь до самого вложенного из выполненных в текущем запуске `SUBCASE`, например:

```
CHECK(false) at subcases.cpp:14 failed!
    message: msg2
    in subcase a
    in subcase b
```

Это нужно, чтобы можно было писать примерно такие тесты:
```c++
TEST_CASE("check bigint") {
    // Исходная настройка (arrange)
    bigint a = 25;
    bigint b = 10;
    // Разные действия (act) и проверка результата (assert)
    SUBCASE("+=") {
        a += b;
        CHECK(a == 35);
    }
    SUBCASE("-=") {
        a -= b;
        CHECK(a == 15);
    }
    // Общая для всех случаев проверка (assert), зависит от того,
    // какой SUBCASE был выполнен перед этим.
    CHECK(b == 10);
}
```

В этом примере тест `check bigint` запустится дважды.
В первый раз он создаст новые переменные `a = 25`, `b = 10`, зайдёт в подслучай `+=`, вызовет `+=`, а в конце проверит, что `b == 10`.
Во второй раз он снова создаст новые переменные `a = 25`, `b = 10`, зайдёт в подслучай `-=`, вызовет `-=`, а в конце проверит, что `b == 10`.
Таким образом, _не требуется_ как-либо запоминать состояние программы в начале `SUBCASE`,
это происходит само собой: `TEST_CASE` запускается каждый раз с нуля.

Если же выполнение ещё не дошло до самого вложенного `SUBCASE` (то есть до элемента списка `X`),
то выводится лишь префикс сообщений `in subcase`.

Обратите внимание, что имена `SUBCASE` вообще никак не влияют на выполнение
и могут хоть все равняться пустым строкам.

Можно считать, что то, какие `SUBCASE` будут выполняться при запуске `TEST_CASE`,
зависит только от действий вашего фреймворка.
Например, положить `SUBCASE` в `if` можно, но изменяемых глобальных переменных
в условии такого `if` не будет.

### Частичные решения
Вы можете реализовать любой префикс из пяти подзаданий ниже и получить частичные баллы.

1. Только макросы `CHECK` и `CHECK_MESSAGE`.
   Гарантируется, что единица трансляции `mytest_main.cpp` не участвует в компиляции.
2. Добавляется макрос `TEST_CASE_REGISTER`.
   Это единственная подзадача, где он разрешён.
   Гарантируется, что программа либо подходит под первое подзадание,
   либо в ней участвует единица трансляции `mytest_main.cpp`.
   В последнем случае макрос `TEST_CASE_REGISTER` вызывается не более чем в одной единице трансляции.
   Более того, все вызовы `TEST_CASE_REGISTER` отсортированы по имени.
3. Добавляется макрос `TEST_CASE`.
   Гарантируется, что программа либо подходит под одно из предыдущих подзаданий,
   либо в ней участвует единица трансляции `mytest_main.cpp` и макрос `TEST_CASE`.
   В последнем случае макрос `TEST_CASE` вызывается не более чем в одной единице трансляции.
   Более того, все вызовы `TEST_CASE` отсортированы по имени.
4. Теперь программа может содержать любое количество единиц трансляции с `TEST_CASE`,
   независимо от того, участвует ли `mytest_main.cpp` в компиляции.
5. Добавляется макрос `SUBCASE`, однако `SUBCASE` не могут вкладываться друг в друга.
6. Ограничений нет.

Обратите внимание, что в подзадачах 3+ макрос `TEST_CASE_REGISTER` встречаться не может.

## Инструкция по сдаче
[Схема стандартная](../common/#формат-сдачи): вы должны выполнить
задание в отдельной ветке своего существующего закрытого репозитория в организации и в нём же создать Pull Request.
Никаких форков!
В этом задании должно хватить веб-интерфейса GitHub, если возникают проблемы — попросите практика помочь.

Если вы хотите сдать только некоторые части задания, удалите остальные тесты из `tests.txt`.

## Система оценки
[Схема стандартная](../common/#система-оценки), баллы:

|Выполненные части|Макс. корректность|Макс. стиль|Макс. итог|
|---|---|---|---|
|1  |1  |1  | 2|
|1-2|2  |2  | 4|
|1-3|3  |2  | 5|
|1-4|4  |3  | 7|
|1-5|5  |4  | 9|
|1-6|7  |5  |12|

Баллы свыше 10 в этом задании считаются бонусными.
Вы их набрать можете, а Идеалов Идеал Идеалович — нет.
Итоговая оценка за практику всё ещё не превышает 10.

## Сроки сдачи
Задание выдано 27 января 2025 (понедельник).
Ниже в каждом случае указано московское время.

* **Дедлайн сдачи:** 3 февраля (понедельник), **22**:59.
* Ожидаемый срок проверки: 10 февраля (понедельник).
* Если первая попытка сдачи достаточно разумна (на усмотрение принимающего),
  то вы можете сделать ещё попытку исправлений или даже несколько.
    * Предложение актуально даже если вы получили автоматический ноль за первую попытку.
    * Выставляется максимум из всех попыток.
* **Срок исправлений**: 17 февраля (понедельник), **22**:59.
